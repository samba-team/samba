#!/bin/sh
#
##############################
# ctdb:                        Starts the clustered tdb daemon
#
# chkconfig:           - 90 36
#
# description:                 Starts and stops the clustered tdb daemon
# pidfile:             /var/run/ctdbd/ctdbd.pid
#

### BEGIN INIT INFO
# Provides:            ctdb
# Required-Start:      $network
# Required-Stop:       $network
# Default-Stop:
# Default-Start:       3 5
# Short-Description:   start and stop ctdb service
# Description:         initscript for the ctdb service
### END INIT INFO

# Source function library.
if [ -f /etc/init.d/functions ] ; then
  . /etc/init.d/functions
elif [ -f /etc/rc.d/init.d/functions ] ; then
  . /etc/rc.d/init.d/functions
fi

[ -f /etc/rc.status ] && {
    . /etc/rc.status
    rc_reset
    LC_ALL=en_US.UTF-8
}

# Avoid using root's TMPDIR
unset TMPDIR

[ -z "$CTDB_BASE" ] && {
    export CTDB_BASE="/etc/ctdb"
}

. $CTDB_BASE/functions
loadconfig network
loadconfig ctdb

# check networking is up (for redhat)
[ "${NETWORKING}" = "no" ] && exit 0

[ -z "$CTDB_RECOVERY_LOCK" ] && {
    echo "You must configure the location of the CTDB_RECOVERY_LOCK"
    exit 1
}
CTDB_OPTIONS="$CTDB_OPTIONS --reclock=$CTDB_RECOVERY_LOCK"

# build up CTDB_OPTIONS variable from optional parameters
[ -z "$CTDB_LOGFILE" ]          || CTDB_OPTIONS="$CTDB_OPTIONS --logfile=$CTDB_LOGFILE"
[ -z "$CTDB_NODES" ]            || CTDB_OPTIONS="$CTDB_OPTIONS --nlist=$CTDB_NODES"
[ -z "$CTDB_SOCKET" ]           || CTDB_OPTIONS="$CTDB_OPTIONS --socket=$CTDB_SOCKET"
[ -z "$CTDB_PUBLIC_ADDRESSES" ] || CTDB_OPTIONS="$CTDB_OPTIONS --public-addresses=$CTDB_PUBLIC_ADDRESSES"
[ -z "$CTDB_PUBLIC_INTERFACE" ] || CTDB_OPTIONS="$CTDB_OPTIONS --public-interface=$CTDB_PUBLIC_INTERFACE"
[ -z "$CTDB_SINGLE_PUBLIC_IP" ] || CTDB_OPTIONS="$CTDB_OPTIONS --single-public-ip=$CTDB_SINGLE_PUBLIC_IP"
[ -z "$CTDB_DBDIR" ]            || CTDB_OPTIONS="$CTDB_OPTIONS --dbdir=$CTDB_DBDIR"
[ -z "$CTDB_DBDIR_PERSISTENT" ] || CTDB_OPTIONS="$CTDB_OPTIONS --dbdir-persistent=$CTDB_DBDIR_PERSISTENT"
[ -z "$CTDB_EVENT_SCRIPT_DIR" ] || CTDB_OPTIONS="$CTDB_OPTIONS --event-script-dir $CTDB_EVENT_SCRIPT_DIR"
[ -z "$CTDB_TRANSPORT" ]        || CTDB_OPTIONS="$CTDB_OPTIONS --transport $CTDB_TRANSPORT"
[ -z "$CTDB_DEBUGLEVEL" ]       || CTDB_OPTIONS="$CTDB_OPTIONS -d $CTDB_DEBUGLEVEL"
[ -z "$CTDB_START_AS_DISABLED" ] || [ "$CTDB_START_AS_DISABLED" != "yes" ] || {
	CTDB_OPTIONS="$CTDB_OPTIONS --start-as-disabled"
}
[ -z "$CTDB_CAPABILITY_RECMASTER" ] || [ "$CTDB_CAPABILITY_RECMASTER" != "no" ] || {
	CTDB_OPTIONS="$CTDB_OPTIONS --no-recmaster"
}
[ -z "$CTDB_CAPABILITY_LMASTER" ] || [ "$CTDB_CAPABILITY_LMASTER" != "no" ] || {
	CTDB_OPTIONS="$CTDB_OPTIONS --no-lmaster"
}
[ -z "$CTDB_LVS_PUBLIC_IP" ] || {
	CTDB_OPTIONS="$CTDB_OPTIONS --lvs --single-public-ip=$CTDB_LVS_PUBLIC_IP"
}
[ -z "$CTDB_SCRIPT_LOG_LEVEL" ] || {
	CTDB_OPTIONS="$CTDB_OPTIONS --script-log-level=$CTDB_SCRIPT_LOG_LEVEL"
}

detect_init_style
export CTDB_INIT_STYLE

if [ "x$CTDB_VALGRIND" = "xyes" ]; then
	init_style="valgrind"
else
	init_style="$CTDB_INIT_STYLE"
fi

set_retval() {
	return $1
}

start() {
        killall -q ctdbd
	echo -n $"Starting ctdbd service: "

	# check all persistent databases that they look ok
	PERSISTENT_DB_DIR="/var/ctdb/persistent"
	[ -z "$CTDB_DBDIR" ] || {
		PERSISTENT_DB_DIR="$CTDB_DBDIR/persistent"
	}
	mkdir -p $PERSISTENT_DB_DIR 2>/dev/null
	for PDBASE in `ls $PERSISTENT_DB_DIR/*.tdb.[0-9] 2>/dev/null`; do
		/usr/bin/tdbdump $PDBASE >/dev/null 2>/dev/null || {
			echo "Persistent database $PDBASE is corrupted! CTDB will not start."
			return 1
		}
	done

	case $init_style in
	    valgrind)
		valgrind -q --log-file=/var/log/ctdb_valgrind /usr/sbin/ctdbd --nosetsched $CTDB_OPTIONS 
		RETVAL=0
		;;
	    suse)
		startproc /usr/sbin/ctdbd $CTDB_OPTIONS
		rc_status -v
		RETVAL=$?
		;;
	    redhat)
		daemon ctdbd $CTDB_OPTIONS
		RETVAL=$?
		echo
		[ $RETVAL -eq 0 ] && touch /var/lock/subsys/ctdb || RETVAL=1
		;;
	    ubuntu)
		start-stop-daemon --start --quiet --background --exec /usr/sbin/ctdbd -- $CTDB_OPTIONS
		RETVAL=$?
		;;
	esac

	sleep 1
	# set any tunables from the config file
	set | grep ^CTDB_SET_ | cut -d_ -f3- | 
	while read v; do
	    varname=`echo $v | cut -d= -f1`
	    value=`echo $v | cut -d= -f2`
	    ctdb setvar $varname $value || RETVAL=1
	done || exit 1

	return $RETVAL
}	

stop() {
	echo -n $"Shutting down ctdbd service: "
	ctdb ping >& /dev/null || {
	    echo -n "  Warning: ctdbd not running ! "
	    case $init_style in
		suse)
		    rc_status -v
		    ;;
		redhat)
		    echo ""
		    ;;
	    esac
	    return 0
	}
	ctdb shutdown
	RETVAL=$?
	count=0
	if [ "$init_style" = "valgrind" ]; then
	    # very crude method
	    sleep 2
	    pkill -9 -f valgrind
	fi
	while killall -q -0 ctdbd; do
	    sleep 1
	    count=`expr $count + 1`
	    [ $count -gt 10 ] && {
		echo -n $"killing ctdbd "
		killall -q -9 ctdbd
		pkill -9 -f $CTDB_BASE/events.d/
	    }
	done
	case $init_style in
	    suse)
		# re-set the return code to the recorded RETVAL
		# in order to print the correct status message
		set_retval $RETVAL
		rc_status -v
		;;
	    redhat)
		echo
		[ $RETVAL -eq 0 ] && rm -f /var/lock/subsys/ctdb
		echo ""
		;;
	esac
	return $RETVAL
}	

restart() {
	stop
	start
}	

status() {
	echo -n $"Checking for ctdbd service: "
	ctdb ping >& /dev/null || {
	    RETVAL=$?
	    echo -n "  ctdbd not running. "
	    case $init_style in
		suse)
		    set_retval $RETVAL
		    rc_status -v
		    ;;
		redhat)
		    echo ""
		    ;;
	    esac
	    return $RETVAL
	}
	echo ""
	ctdb status
}	


case "$1" in
  start)
  	start
	;;
  stop)
  	stop
	;;
  restart|reload)
  	restart
	;;
  status)
  	status
	;;
  condrestart)
  	ctdb status > /dev/null && restart || :
	;;
  cron)
	# used from cron to auto-restart ctdb
  	ctdb status > /dev/null || restart
	;;
  *)
	echo $"Usage: $0 {start|stop|restart|status|cron|condrestart}"
	exit 1
esac

exit $?
