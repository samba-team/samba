#!/bin/sh
############################
# main event script for ctdb
#
# This script is called with one of the following sets of arguments
#     startup    : called when ctdb starts
#     shutdown   : called when ctdb shuts down
#     takeip     : called when an IP address is taken over
#     releaseip  : called when an IP address is released
#     recovered  : called when ctdb has finished a recovery event

. $CTDB_BASE/functions
loadconfig

update_config_from_tdb() {
	# Pull optional ctdb configuration data out of config.tdb
	PUBLICADDRESSESKEY='public_addresses:node#'`ctdb -t 1 xpnn|sed -e "s/.*://"`
	rm -f $CTDB_VARDIR/state/public_addresses
	ctdb pfetch config.tdb $PUBLICADDRESSESKEY $CTDB_VARDIR/state/public_addresses 2>/dev/null
	[ "$?" = "0" ] && [ `stat --format="%s" /etc/ctdb/state/public_addresses` != "0" ] && [ ! -z "$CTDB_PUBLIC_ADDRESSES" ] && {
		diff $CTDB_VARDIR/state/public_addresses $CTDB_PUBLIC_ADDRESSES >/dev/null 2>/dev/null
		[ $? = "0" ] || {
			echo CTDB public address configuration had been updated.
			echo Extracting new configuration from database.
			diff $CTDB_VARDIR/state/public_addresses $CTDB_PUBLIC_ADDRESSES
			cp $CTDB_VARDIR/state/public_addresses $CTDB_PUBLIC_ADDRESSES
			echo Restarting CTDB
			service ctdb restart &
		}
	}
}

case "$1" in 
     init)
        # make sure we have a blank state directory for the scripts to work with
	/bin/rm -rf $CTDB_VARDIR/state
	/bin/mkdir -p $CTDB_VARDIR/state || {
	    ret=$?
	    echo "/bin/mkdir -p $CTDB_VARDIR/state - failed - $ret"
	    exit $ret
	}
	;;

     setup)
	# set any tunables from the config file
	set | grep ^CTDB_SET_ | cut -d_ -f3- | 
	while read v; do
	    varname=`echo $v | cut -d= -f1`
	    value=`echo $v | cut -d= -f2`
	    ctdb setvar $varname $value || exit 1
	    echo "Set $varname to $value"
	done || exit 1
	;;

    startup)
	update_config_from_tdb &
	;;
    monitor)
	# We should never enter swap, so SwapTotal == SwapFree.
	[ "$CTDB_CHECK_SWAP_IS_NOT_USED" = "yes" ] && {
	    if [ -n "`grep '^Swap\(Total\|Free\)' /proc/meminfo | uniq -s 10 -u`" ]; then
		echo We are swapping:
		cat /proc/meminfo
		ps auxfww
	    fi
	}

	# warn when we get low on memory
	[ -z "$CTDB_MONITOR_FREE_MEMORY_WARN" ] || {
		FREE_MEM=`free -m | grep "buffers/cache" | while read A B C D ;do /bin/echo -n $D ; done`
		[ `expr "$FREE_MEM" "<" "$CTDB_MONITOR_FREE_MEMORY_WARN"` != "0" ] && {
			echo "Running low on memory. Free:$FREE_MEM while CTDB treshold is $CTDB_MONITOR_FREE_MEMORY_WARN"
		}
	}

	# monitor that we are not running out of memory
	[ -z "$CTDB_MONITOR_FREE_MEMORY" ] || {
		FREE_MEM=`free -m | grep "buffers/cache" | while read A B C D ;do /bin/echo -n $D ; done`
		[ `expr "$FREE_MEM" "<" "$CTDB_MONITOR_FREE_MEMORY"` != "0" ] && {
			echo "OOM. Free:$FREE_MEM while CTDB treshold is $CTDB_MONITOR_FREE_MEMORY"
			cat /proc/meminfo
			ps auxfww
			echo m > /proc/sysrq-trigger
			ctdb disable
			sleep 3
			ctdb shutdown
		}
	}
	;;

    *)
	ctdb_standard_event_handler "$@"
	;;
esac

# all OK
exit 0
