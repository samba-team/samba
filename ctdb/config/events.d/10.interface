#!/bin/sh

#################################
# interface event script for ctdb
# this adds/removes IPs from your 
# public interface

. /etc/ctdb/functions
loadconfig ctdb

cmd="$1"
shift

[ -z "$CTDB_PUBLIC_ADDRESSES" ] && {
	CTDB_PUBLIC_ADDRESSES=/etc/ctdb/public_addresses
}

[ ! -f "$CTDB_PUBLIC_ADDRESSES" ] && {
	echo "`date` No public addresses file found. Nothing to do for 10.interfaces"
	exit 0
}

################################################
# kill off any TCP connections with the given IP
kill_tcp_connections() {
    _IP="$1"    
    _failed=0

    _killcount=0
    connfile="/etc/ctdb/state/connections.$_IP"
    netstat -tn |egrep "^tcp.*\s+$_IP:.*ESTABLISHED" | awk '{print $4" "$5}' > $connfile
    while read dest src; do
	srcip=`echo $src | cut -d: -f1`
	srcport=`echo $src | cut -d: -f2`
	destip=`echo $dest | cut -d: -f1`
	destport=`echo $dest | cut -d: -f2`
	ctdb killtcp $srcip:$srcport $destip:$destport >/dev/null 2>&1 || _failed=1
	echo "`date` Killing TCP connection $srcip:$srcport $destip:$destport"
	_killcount=`expr $_killcount + 1`
    done < $connfile
    /bin/rm -f $connfile
    [ $_failed = 0 ] || {
	echo "`date` Failed to send killtcp control"
	return;
    }
    [ $_killcount -gt 0 ] || {
	return;
    }
    _count=0
    while netstat -tn |egrep "^tcp.*\s+$_IP:.*ESTABLISHED" > /dev/null; do
	sleep 1
	_count=`expr $_count + 1`
	[ $_count -gt 3 ] && {
	    echo "`date` Timed out killing tcp connections for IP $_IP"
	    return;
	}
    done
    echo "`date` killed $_killcount TCP connections to released IP $_IP"
}

case $cmd in 
     #############################
     # called when ctdbd starts up
     startup)
	# make sure that we only respond to ARP messages from the NIC where
	# a particular ip address is associated.
	[ -f /proc/sys/net/ipv4/conf/all/arp_filter ] && {
	    echo 1 > /proc/sys/net/ipv4/conf/all/arp_filter
	}
	cat "$CTDB_PUBLIC_ADDRESSES" | cut -d/ -f1 | while read _IP; do
		_IP_HELD=`/sbin/ip addr show | grep "inet $_IP/"`
		[ -z "$_IP_HELD" ] || {
			_IFACE=`echo $_IP_HELD | sed -e "s/.*\s//"`
			_NM=`echo $_IP_HELD | sed -e "s/.*$_IP\///" -e "s/\s.*//"`
			echo "`date` Removing public address $_IP/$_NM from device $_IFACE"
			/sbin/ip addr del $_IP/$_NM dev $_IFACE
		}
	done
	;;


     ################################################
     # called when ctdbd wants to claim an IP address
     takeip)
	if [ $# != 3 ]; then
	   echo "`date` must supply interface, IP and maskbits"
	   exit 1
	fi
	iface=$1
	ip=$2
	maskbits=$3

	# we make sure the interface is up first
	/sbin/ip link set $iface up || {
		 echo "`/bin/date` Failed to bringup interface $iface"
		 exit 1
	}
	/sbin/ip addr add $ip/$maskbits dev $iface || {
		 echo "`/bin/date` Failed to add $ip/$maskbits on dev $iface"
		 exit 1
	}
	# cope with the script being killed while we have the interface blocked
	/sbin/iptables -D INPUT -i $iface -d $ip -j DROP 2> /dev/null

	# flush our route cache
	echo 1 > /proc/sys/net/ipv4/route/flush
	;;


     ##################################################
     # called when ctdbd wants to release an IP address
     releaseip)
	if [ $# != 3 ]; then
	   echo "`/bin/date` must supply interface, IP and maskbits"
	   exit 1
	fi

	# releasing an IP is a bit more complex than it seems. Once the IP
	# is released, any open tcp connections to that IP on this host will end
	# up being stuck. Some of them (such as NFS connections) will be unkillable
	# so we need to use the killtcp ctdb function to kill them off. We also
	# need to make sure that no new connections get established while we are 
	# doing this! So what we do is this:
	# 1) firewall this IP, so no new external packets arrive for it
	# 2) use netstat -tn to find existing connections, and kill them 
	# 3) remove the IP from the interface
	# 4) remove the firewall rule
	iface=$1
	ip=$2
	maskbits=$3

	failed=0
	# we do an extra delete to cope with the script being killed
	/sbin/iptables -D INPUT -i $iface -d $ip -j DROP 2> /dev/null
	/sbin/iptables -I INPUT -i $iface -d $ip -j DROP
	kill_tcp_connections $ip

	# the ip tool will delete all secondary IPs if this is the primary. To work around
	# this _very_ annoying behaviour we have to keep a record of the secondaries and re-add
	# them afterwards. yuck
	secondaries=""
	if /sbin/ip addr list dev $iface primary | grep "inet $ip/$maskbits " > /dev/null; then
	    secondaries=`/sbin/ip addr list dev $iface secondary | grep " inet " | awk '{print $2}'`
	fi
	/sbin/ip addr del $ip/$maskbits dev $iface || failed=1
	[ -z "$secondaries" ] || {
	    for i in $secondaries; do
		if /sbin/ip addr list dev $iface | grep "inet $i" > /dev/null; then
		    echo "`date` kept secondary $i on dev $iface"
		else 
		    echo "`date` re-adding secondary address $i to dev $iface"
		    /sbin/ip addr add $i dev $iface || failed=1		
		fi
	    done
	}
	/sbin/iptables -D INPUT -i $iface -d $ip -j DROP
	[ $failed = 0 ] || {
		 echo "`/bin/date` Failed to del $ip on dev $iface"
		 exit 1
	}

	# flush our route cache
	echo 1 > /proc/sys/net/ipv4/route/flush
	;;


     ###########################################
     # called when ctdbd has finished a recovery
     recovered)
	;;

     ####################################
     # called when ctdbd is shutting down
     shutdown)
	;;

     monitor)
	[ -x /usr/sbin/ethtool ] && {
	    [ -z "$CTDB_PUBLIC_INTERFACE" ] || {
	    	/usr/sbin/ethtool $CTDB_PUBLIC_INTERFACE | grep 'Link detected: yes' > /dev/null || {
		    echo "`date` ERROR: No link on the public network interface $CTDB_PUBLIC_INTERFACE"
		    exit 1
	    	}
	    }
	    cat $CTDB_PUBLIC_ADDRESSES | sed -e "s/^[^\t ]*[\t ]*//" -e "s/[\t ]*$//" | 
	    sort | uniq | while read IFACE; do
		[ -z "$IFACE" ] || {
	    	    /usr/sbin/ethtool $IFACE | grep 'Link detected: yes' > /dev/null || {
			echo "`date` ERROR: No link on the public network interface $IFACE"
			exit 1
	    	    }
		}
	    done
	}
	;;

esac

exit 0



