#!/bin/sh
# script to manage nfs in a clustered environment

start_nfs() {
	/bin/mkdir -p $CTDB_VARDIR/state/nfs
	/bin/mkdir -p $CTDB_VARDIR/state/statd/ip
	startstop_nfs stop
	startstop_nfs start
	echo 1 > /proc/sys/net/ipv4/tcp_tw_recycle
}

. $CTDB_BASE/functions

service_name="nfs"
service_start="start_nfs"
service_stop="startstop_nfs stop"

loadconfig

ctdb_start_stop_service

case "$1" in 
     init)
	# read statd from persistent database
	;;
     startup)
	ctdb_service_start
	mkdir -p $CTDB_VARDIR/state/statd
	touch $CTDB_VARDIR/state/statd/update-trigger
	;;

     shutdown)
	ctdb_service_stop
	;;

     takeip)
	ctdb_service_set_reconfigure
	;;

     releaseip)
	ctdb_service_set_reconfigure
	;;

      monitor)
	if ctdb_service_needs_reconfigure ; then
	    ctdb_service_reconfigure
	    exit 0
	fi

	update_tickles 2049

	# check that statd responds to rpc requests
	# if statd is not running we try to restart it
	rpcinfo -u localhost 100024 1 > /dev/null || {
		RPCSTATDOPTS=""
		[ -n "$STATD_HOSTNAME" ] && RPCSTATDOPTS="$RPCSTATDOPTS -n $STATD_HOSTNAME"
		[ -n "$STATD_PORT" ] && RPCSTATDOPTS="$RPCSTATDOPTS -p $STATD_PORT"
		[ -n "$STATD_OUTGOING_PORT" ] && RPCSTATDOPTS="$RPCSTATDOPTS -o $STATD_OUTGOING_PORT"
		rpc.statd $RPCSTATDOPTS 
		echo "ERROR: STATD is not responding. Trying to restart it. [rpc.statd $RPCSTATDOPTS]"
	}


	# check that NFS responds to rpc requests
	[ "$CTDB_NFS_SKIP_KNFSD_ALIVE_CHECK" = "yes" ] || {
	    (ctdb_check_rpc "NFS" 100003 3)
	    [ $? = "0" ] || {
		echo "Trying to restart NFS service"
		startstop_nfs restart
		exit 1
	    }
	}

	# and that its directories are available
	[ "$CTDB_NFS_SKIP_SHARE_CHECK" = "yes" ] || {
	    exportfs | grep -v '^#' | grep '^/' |
	    sed -e 's/[[:space:]]\+[^[:space:]]*$//' |
	    ctdb_check_directories
	} || exit $?

	# check that lockd responds to rpc requests
	(ctdb_check_rpc "lockd" 100021 1)
	[ $? = "0" ] || {
		echo "Trying to restart lock manager service"
		startstop_nfs restart
		startstop_nfslock restart
		exit 1
	}

	# mount needs special handling since it is sometimes not started
	# correctly on RHEL5
	rpcinfo -u localhost 100005 1 > /dev/null || {
		echo "ERROR: MOUNTD is not running. Trying to restart it."
		RPCMOUNTDOPTS=""
		[ -n "$MOUNTD_PORT" ] && RPCMOUNTDOPTS="$RPCMOUNTDOPTS -p $MOUNTD_PORT"
		killall -q -9 rpc.mountd
		rpc.mountd $RPCMOUNTDOPTS &
		exit 1
	}
	# rquotad needs special handling since it is sometimes not started
	# correctly on RHEL5
	# this is not a critical service so we dont flag the node as unhealthy
	rpcinfo -u localhost 100011 1 > /dev/null || {
		echo "ERROR: RQUOTAD is not running. Trying to restart it."
		RPCRQUOTADOPTS=""
		[ -n "$RQUOTAD_PORT" ] && RPCRQUOTADOPTS="$RPCRQUOTADOPTS -p $RQUOTAD_PORT"
		killall -q -9 rpc.rquotad
		rpc.rquotad $RPCRQUOTADOPTS &
	}

	# once every 60 seconds, update the statd state database for which
	# clients need notifications
	LAST_UPDATE=`stat --printf="%Y" $CTDB_VARDIR/state/statd/update-trigger`
	CURRENT_TIME=`date +"%s"`
	expr "$CURRENT_TIME" ">" "(" "$LAST_UPDATE" "+" "60" ")" >/dev/null 2>/dev/null
	[ $? = "0" ] && {
	    mkdir -p $CTDB_VARDIR/state/statd
	    touch $CTDB_VARDIR/state/statd/update-trigger
	    $CTDB_BASE/statd-callout updatelocal &
	    $CTDB_BASE/statd-callout updateremote &
	}
       	;;

    ipreallocated)
	# if the ips have been reallocated, we must restart the lockmanager
	# across all nodes and ping all statd listeners
	[ -x $CTDB_BASE/statd-callout ] && {
		$CTDB_BASE/statd-callout notify &
	} >/dev/null 2>&1
	;;
    *)
	ctdb_standard_event_handler "$@"
	;;
esac

exit 0
