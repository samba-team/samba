/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "librpc/gen_ndr/srv_srvsvc.h"

static BOOL api_srvsvc_NetCharDevEnum(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevEnum r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetCharDevEnum");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetCharDevEnum(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevEnum, &r);
	
	ZERO_STRUCT(r.out);
	r.out.level = r.in.level;
	r.out.ctr = r.in.ctr;
	r.out.totalentries = talloc_zero(mem_ctx, uint32_t);
	if (r.out.totalentries == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.resume_handle = r.in.resume_handle;
	r.out.result = _srvsvc_NetCharDevEnum(p, r.in.server_unc, r.in.level, r.in.ctr, r.in.max_buffer, r.out.totalentries, r.in.resume_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevEnum, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetCharDevEnum(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetCharDevGetInfo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevGetInfo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetCharDevGetInfo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetCharDevGetInfo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevGetInfo, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_zero(mem_ctx, union srvsvc_NetCharDevInfo);
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _srvsvc_NetCharDevGetInfo(p, r.in.server_unc, r.in.device_name, r.in.level, r.out.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevGetInfo, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetCharDevGetInfo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetCharDevControl(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevControl r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetCharDevControl");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetCharDevControl(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevControl, &r);
	
	r.out.result = _srvsvc_NetCharDevControl(p, r.in.server_unc, r.in.device_name, r.in.opcode);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevControl, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetCharDevControl(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetCharDevQEnum(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevQEnum r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetCharDevQEnum");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetCharDevQEnum(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevQEnum, &r);
	
	ZERO_STRUCT(r.out);
	r.out.level = r.in.level;
	r.out.ctr = r.in.ctr;
	r.out.totalentries = talloc_zero(mem_ctx, uint32_t);
	if (r.out.totalentries == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.resume_handle = r.in.resume_handle;
	r.out.result = _srvsvc_NetCharDevQEnum(p, r.in.server_unc, r.in.user, r.in.level, r.in.ctr, r.in.max_buffer, r.out.totalentries, r.in.resume_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevQEnum, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetCharDevQEnum(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetCharDevQGetInfo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevQGetInfo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetCharDevQGetInfo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetCharDevQGetInfo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevQGetInfo, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_zero(mem_ctx, union srvsvc_NetCharDevQInfo);
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _srvsvc_NetCharDevQGetInfo(p, r.in.server_unc, r.in.queue_name, r.in.user, r.in.level, r.out.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevQGetInfo, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetCharDevQGetInfo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetCharDevQSetInfo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevQSetInfo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetCharDevQSetInfo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetCharDevQSetInfo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevQSetInfo, &r);
	
	ZERO_STRUCT(r.out);
	r.out.parm_error = r.in.parm_error;
	r.out.result = _srvsvc_NetCharDevQSetInfo(p, r.in.server_unc, r.in.queue_name, r.in.level, r.in.info, r.in.parm_error);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevQSetInfo, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetCharDevQSetInfo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetCharDevQPurge(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevQPurge r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetCharDevQPurge");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetCharDevQPurge(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevQPurge, &r);
	
	r.out.result = _srvsvc_NetCharDevQPurge(p, r.in.server_unc, r.in.queue_name);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevQPurge, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetCharDevQPurge(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetCharDevQPurgeSelf(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevQPurgeSelf r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetCharDevQPurgeSelf");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetCharDevQPurgeSelf(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevQPurgeSelf, &r);
	
	r.out.result = _srvsvc_NetCharDevQPurgeSelf(p, r.in.server_unc, r.in.queue_name, r.in.computer_name);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevQPurgeSelf, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetCharDevQPurgeSelf(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetConnEnum(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetConnEnum r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetConnEnum");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetConnEnum(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetConnEnum, &r);
	
	ZERO_STRUCT(r.out);
	r.out.level = r.in.level;
	r.out.ctr = r.in.ctr;
	r.out.totalentries = talloc_zero(mem_ctx, uint32_t);
	if (r.out.totalentries == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.resume_handle = r.in.resume_handle;
	r.out.result = _srvsvc_NetConnEnum(p, r.in.server_unc, r.in.path, r.in.level, r.in.ctr, r.in.max_buffer, r.out.totalentries, r.in.resume_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetConnEnum, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetConnEnum(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetFileEnum(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetFileEnum r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetFileEnum");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetFileEnum(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetFileEnum, &r);
	
	ZERO_STRUCT(r.out);
	r.out.level = r.in.level;
	r.out.ctr = r.in.ctr;
	r.out.totalentries = talloc_zero(mem_ctx, uint32_t);
	if (r.out.totalentries == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.resume_handle = r.in.resume_handle;
	r.out.result = _srvsvc_NetFileEnum(p, r.in.server_unc, r.in.path, r.in.user, r.in.level, r.in.ctr, r.in.max_buffer, r.out.totalentries, r.in.resume_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetFileEnum, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetFileEnum(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetFileGetInfo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetFileGetInfo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetFileGetInfo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetFileGetInfo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetFileGetInfo, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_zero(mem_ctx, union srvsvc_NetFileInfo);
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _srvsvc_NetFileGetInfo(p, r.in.server_unc, r.in.fid, r.in.level, r.out.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetFileGetInfo, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetFileGetInfo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetFileClose(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetFileClose r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetFileClose");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetFileClose(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetFileClose, &r);
	
	r.out.result = _srvsvc_NetFileClose(p, r.in.server_unc, r.in.fid);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetFileClose, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetFileClose(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetSessEnum(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetSessEnum r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetSessEnum");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetSessEnum(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetSessEnum, &r);
	
	ZERO_STRUCT(r.out);
	r.out.level = r.in.level;
	r.out.ctr = r.in.ctr;
	r.out.totalentries = talloc_zero(mem_ctx, uint32_t);
	if (r.out.totalentries == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.resume_handle = r.in.resume_handle;
	r.out.result = _srvsvc_NetSessEnum(p, r.in.server_unc, r.in.client, r.in.user, r.in.level, r.in.ctr, r.in.max_buffer, r.out.totalentries, r.in.resume_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSessEnum, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetSessEnum(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetSessDel(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetSessDel r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetSessDel");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetSessDel(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetSessDel, &r);
	
	r.out.result = _srvsvc_NetSessDel(p, r.in.server_unc, r.in.client, r.in.user);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSessDel, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetSessDel(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetShareAdd(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetShareAdd r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetShareAdd");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetShareAdd(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareAdd, &r);
	
	ZERO_STRUCT(r.out);
	r.out.parm_error = r.in.parm_error;
	r.out.result = _srvsvc_NetShareAdd(p, r.in.server_unc, r.in.level, r.in.info, r.in.parm_error);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareAdd, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetShareAdd(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetShareEnumAll(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetShareEnumAll r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetShareEnumAll");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetShareEnumAll(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareEnumAll, &r);
	
	ZERO_STRUCT(r.out);
	r.out.level = r.in.level;
	r.out.ctr = r.in.ctr;
	r.out.totalentries = talloc_zero(mem_ctx, uint32_t);
	if (r.out.totalentries == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.resume_handle = r.in.resume_handle;
	r.out.result = _srvsvc_NetShareEnumAll(p, r.in.server_unc, r.in.level, r.in.ctr, r.in.max_buffer, r.out.totalentries, r.in.resume_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareEnumAll, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetShareEnumAll(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetShareGetInfo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetShareGetInfo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetShareGetInfo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetShareGetInfo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareGetInfo, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_zero(mem_ctx, union srvsvc_NetShareInfo);
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _srvsvc_NetShareGetInfo(p, r.in.server_unc, r.in.share_name, r.in.level, r.out.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareGetInfo, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetShareGetInfo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetShareSetInfo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetShareSetInfo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetShareSetInfo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetShareSetInfo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareSetInfo, &r);
	
	ZERO_STRUCT(r.out);
	r.out.parm_error = r.in.parm_error;
	r.out.result = _srvsvc_NetShareSetInfo(p, r.in.server_unc, r.in.share_name, r.in.level, r.in.info, r.in.parm_error);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareSetInfo, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetShareSetInfo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetShareDel(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetShareDel r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetShareDel");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetShareDel(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareDel, &r);
	
	r.out.result = _srvsvc_NetShareDel(p, r.in.server_unc, r.in.share_name, r.in.reserved);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareDel, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetShareDel(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetShareDelSticky(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetShareDelSticky r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetShareDelSticky");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetShareDelSticky(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareDelSticky, &r);
	
	r.out.result = _srvsvc_NetShareDelSticky(p, r.in.server_unc, r.in.share_name, r.in.reserved);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareDelSticky, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetShareDelSticky(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetShareCheck(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetShareCheck r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetShareCheck");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetShareCheck(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareCheck, &r);
	
	ZERO_STRUCT(r.out);
	r.out.type = talloc_zero(mem_ctx, enum srvsvc_ShareType);
	if (r.out.type == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _srvsvc_NetShareCheck(p, r.in.server_unc, r.in.device_name, r.out.type);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareCheck, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetShareCheck(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetSrvGetInfo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetSrvGetInfo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetSrvGetInfo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetSrvGetInfo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetSrvGetInfo, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_zero(mem_ctx, union srvsvc_NetSrvInfo);
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _srvsvc_NetSrvGetInfo(p, r.in.server_unc, r.in.level, r.out.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSrvGetInfo, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetSrvGetInfo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetSrvSetInfo(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetSrvSetInfo r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetSrvSetInfo");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetSrvSetInfo(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetSrvSetInfo, &r);
	
	ZERO_STRUCT(r.out);
	r.out.parm_error = r.in.parm_error;
	r.out.result = _srvsvc_NetSrvSetInfo(p, r.in.server_unc, r.in.level, r.in.info, r.in.parm_error);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSrvSetInfo, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetSrvSetInfo(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetDiskEnum(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetDiskEnum r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetDiskEnum");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetDiskEnum(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetDiskEnum, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = r.in.info;
	r.out.totalentries = talloc_zero(mem_ctx, uint32_t);
	if (r.out.totalentries == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.resume_handle = r.in.resume_handle;
	r.out.result = _srvsvc_NetDiskEnum(p, r.in.server_unc, r.in.level, r.in.info, r.in.maxlen, r.out.totalentries, r.in.resume_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetDiskEnum, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetDiskEnum(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetServerStatisticsGet(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetServerStatisticsGet r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetServerStatisticsGet");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetServerStatisticsGet(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetServerStatisticsGet, &r);
	
	ZERO_STRUCT(r.out);
	r.out.stats = talloc_zero(mem_ctx, struct srvsvc_Statistics);
	if (r.out.stats == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _srvsvc_NetServerStatisticsGet(p, r.in.server_unc, r.in.service, r.in.level, r.in.options, r.out.stats);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetServerStatisticsGet, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetServerStatisticsGet(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetTransportAdd(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetTransportAdd r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetTransportAdd");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetTransportAdd(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetTransportAdd, &r);
	
	r.out.result = _srvsvc_NetTransportAdd(p, r.in.server_unc, r.in.level, r.in.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetTransportAdd, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetTransportAdd(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetTransportEnum(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetTransportEnum r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetTransportEnum");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetTransportEnum(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetTransportEnum, &r);
	
	ZERO_STRUCT(r.out);
	r.out.level = r.in.level;
	r.out.transports = r.in.transports;
	r.out.totalentries = talloc_zero(mem_ctx, uint32_t);
	if (r.out.totalentries == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.resume_handle = r.in.resume_handle;
	r.out.result = _srvsvc_NetTransportEnum(p, r.in.server_unc, r.in.level, r.in.transports, r.in.max_buffer, r.out.totalentries, r.in.resume_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetTransportEnum, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetTransportEnum(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetTransportDel(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetTransportDel r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetTransportDel");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetTransportDel(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetTransportDel, &r);
	
	r.out.result = _srvsvc_NetTransportDel(p, r.in.server_unc, r.in.unknown, r.in.transport);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetTransportDel, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetTransportDel(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetRemoteTOD(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetRemoteTOD r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetRemoteTOD");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetRemoteTOD(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetRemoteTOD, &r);
	
	ZERO_STRUCT(r.out);
	r.out.info = talloc_zero(mem_ctx, struct srvsvc_NetRemoteTODInfo);
	if (r.out.info == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _srvsvc_NetRemoteTOD(p, r.in.server_unc, r.out.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetRemoteTOD, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetRemoteTOD(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetSetServiceBits(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetSetServiceBits r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetSetServiceBits");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetSetServiceBits(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetSetServiceBits, &r);
	
	r.out.result = _srvsvc_NetSetServiceBits(p, r.in.server_unc, r.in.transport, r.in.servicebits, r.in.updateimmediately);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSetServiceBits, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetSetServiceBits(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetPathType(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetPathType r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetPathType");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetPathType(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetPathType, &r);
	
	ZERO_STRUCT(r.out);
	r.out.pathtype = talloc_zero(mem_ctx, uint32_t);
	if (r.out.pathtype == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _srvsvc_NetPathType(p, r.in.server_unc, r.in.path, r.in.pathflags, r.out.pathtype);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetPathType, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetPathType(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetPathCanonicalize(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetPathCanonicalize r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetPathCanonicalize");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetPathCanonicalize(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetPathCanonicalize, &r);
	
	ZERO_STRUCT(r.out);
	r.out.can_path = talloc_zero_array(mem_ctx, uint8_t, r.in.maxbuf);
	if (r.out.can_path == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.pathtype = r.in.pathtype;
	r.out.result = _srvsvc_NetPathCanonicalize(p, r.in.server_unc, r.in.path, r.out.can_path, r.in.maxbuf, r.in.prefix, r.in.pathtype, r.in.pathflags);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetPathCanonicalize, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetPathCanonicalize(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetPathCompare(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetPathCompare r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetPathCompare");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetPathCompare(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetPathCompare, &r);
	
	r.out.result = _srvsvc_NetPathCompare(p, r.in.server_unc, r.in.path1, r.in.path2, r.in.pathtype, r.in.pathflags);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetPathCompare, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetPathCompare(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetNameValidate(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetNameValidate r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetNameValidate");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetNameValidate(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetNameValidate, &r);
	
	r.out.result = _srvsvc_NetNameValidate(p, r.in.server_unc, r.in.name, r.in.name_type, r.in.flags);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetNameValidate, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetNameValidate(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NETRPRNAMECANONICALIZE(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NETRPRNAMECANONICALIZE r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NETRPRNAMECANONICALIZE");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NETRPRNAMECANONICALIZE(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NETRPRNAMECANONICALIZE, &r);
	
	r.out.result = _srvsvc_NETRPRNAMECANONICALIZE(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRPRNAMECANONICALIZE, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NETRPRNAMECANONICALIZE(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetPRNameCompare(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetPRNameCompare r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetPRNameCompare");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetPRNameCompare(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetPRNameCompare, &r);
	
	r.out.result = _srvsvc_NetPRNameCompare(p, r.in.server_unc, r.in.name1, r.in.name2, r.in.name_type, r.in.flags);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetPRNameCompare, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetPRNameCompare(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetShareEnum(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetShareEnum r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetShareEnum");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetShareEnum(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareEnum, &r);
	
	ZERO_STRUCT(r.out);
	r.out.level = r.in.level;
	r.out.ctr = r.in.ctr;
	r.out.totalentries = talloc_zero(mem_ctx, uint32_t);
	if (r.out.totalentries == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.resume_handle = r.in.resume_handle;
	r.out.result = _srvsvc_NetShareEnum(p, r.in.server_unc, r.in.level, r.in.ctr, r.in.max_buffer, r.out.totalentries, r.in.resume_handle);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareEnum, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetShareEnum(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetShareDelStart(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetShareDelStart r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetShareDelStart");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetShareDelStart(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareDelStart, &r);
	
	ZERO_STRUCT(r.out);
	r.out.hnd = talloc_zero(mem_ctx, struct policy_handle);
	if (r.out.hnd == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _srvsvc_NetShareDelStart(p, r.in.server_unc, r.in.share, r.in.reserved, r.out.hnd);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareDelStart, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetShareDelStart(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetShareDelCommit(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetShareDelCommit r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetShareDelCommit");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetShareDelCommit(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareDelCommit, &r);
	
	ZERO_STRUCT(r.out);
	r.out.hnd = r.in.hnd;
	r.out.result = _srvsvc_NetShareDelCommit(p, r.in.hnd);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareDelCommit, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetShareDelCommit(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetGetFileSecurity(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetGetFileSecurity r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetGetFileSecurity");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetGetFileSecurity(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetGetFileSecurity, &r);
	
	ZERO_STRUCT(r.out);
	r.out.sd_buf = talloc_zero(mem_ctx, struct sec_desc_buf);
	if (r.out.sd_buf == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	r.out.result = _srvsvc_NetGetFileSecurity(p, r.in.server_unc, r.in.share, r.in.file, r.in.securityinformation, r.out.sd_buf);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetGetFileSecurity, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetGetFileSecurity(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetSetFileSecurity(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetSetFileSecurity r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetSetFileSecurity");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetSetFileSecurity(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetSetFileSecurity, &r);
	
	r.out.result = _srvsvc_NetSetFileSecurity(p, r.in.server_unc, r.in.share, r.in.file, r.in.securityinformation, r.in.sd_buf);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSetFileSecurity, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetSetFileSecurity(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetServerTransportAddEx(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetServerTransportAddEx r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetServerTransportAddEx");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetServerTransportAddEx(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetServerTransportAddEx, &r);
	
	r.out.result = _srvsvc_NetServerTransportAddEx(p, r.in.server_unc, r.in.level, r.in.info);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetServerTransportAddEx, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetServerTransportAddEx(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NetServerSetServiceBitsEx(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NetServerSetServiceBitsEx r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NetServerSetServiceBitsEx");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NetServerSetServiceBitsEx(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NetServerSetServiceBitsEx, &r);
	
	r.out.result = _srvsvc_NetServerSetServiceBitsEx(p, r.in.server_unc, r.in.emulated_server_unc, r.in.transport, r.in.servicebitsofinterest, r.in.servicebits, r.in.updateimmediately);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NetServerSetServiceBitsEx, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NetServerSetServiceBitsEx(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NETRDFSGETVERSION(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSGETVERSION r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NETRDFSGETVERSION");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NETRDFSGETVERSION(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSGETVERSION, &r);
	
	r.out.result = _srvsvc_NETRDFSGETVERSION(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSGETVERSION, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NETRDFSGETVERSION(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NETRDFSCREATELOCALPARTITION(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSCREATELOCALPARTITION r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NETRDFSCREATELOCALPARTITION");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NETRDFSCREATELOCALPARTITION(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSCREATELOCALPARTITION, &r);
	
	r.out.result = _srvsvc_NETRDFSCREATELOCALPARTITION(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSCREATELOCALPARTITION, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NETRDFSCREATELOCALPARTITION(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NETRDFSDELETELOCALPARTITION(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSDELETELOCALPARTITION r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NETRDFSDELETELOCALPARTITION");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NETRDFSDELETELOCALPARTITION(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSDELETELOCALPARTITION, &r);
	
	r.out.result = _srvsvc_NETRDFSDELETELOCALPARTITION(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSDELETELOCALPARTITION, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NETRDFSDELETELOCALPARTITION(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NETRDFSSETLOCALVOLUMESTATE(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSSETLOCALVOLUMESTATE r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NETRDFSSETLOCALVOLUMESTATE");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NETRDFSSETLOCALVOLUMESTATE(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSSETLOCALVOLUMESTATE, &r);
	
	r.out.result = _srvsvc_NETRDFSSETLOCALVOLUMESTATE(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSSETLOCALVOLUMESTATE, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NETRDFSSETLOCALVOLUMESTATE(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NETRDFSSETSERVERINFO(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSSETSERVERINFO r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NETRDFSSETSERVERINFO");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NETRDFSSETSERVERINFO(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSSETSERVERINFO, &r);
	
	r.out.result = _srvsvc_NETRDFSSETSERVERINFO(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSSETSERVERINFO, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NETRDFSSETSERVERINFO(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NETRDFSCREATEEXITPOINT(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSCREATEEXITPOINT r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NETRDFSCREATEEXITPOINT");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NETRDFSCREATEEXITPOINT(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSCREATEEXITPOINT, &r);
	
	r.out.result = _srvsvc_NETRDFSCREATEEXITPOINT(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSCREATEEXITPOINT, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NETRDFSCREATEEXITPOINT(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NETRDFSDELETEEXITPOINT(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSDELETEEXITPOINT r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NETRDFSDELETEEXITPOINT");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NETRDFSDELETEEXITPOINT(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSDELETEEXITPOINT, &r);
	
	r.out.result = _srvsvc_NETRDFSDELETEEXITPOINT(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSDELETEEXITPOINT, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NETRDFSDELETEEXITPOINT(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NETRDFSMODIFYPREFIX(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSMODIFYPREFIX r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NETRDFSMODIFYPREFIX");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NETRDFSMODIFYPREFIX(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSMODIFYPREFIX, &r);
	
	r.out.result = _srvsvc_NETRDFSMODIFYPREFIX(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSMODIFYPREFIX, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NETRDFSMODIFYPREFIX(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NETRDFSFIXLOCALVOLUME(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSFIXLOCALVOLUME r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NETRDFSFIXLOCALVOLUME");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NETRDFSFIXLOCALVOLUME(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSFIXLOCALVOLUME, &r);
	
	r.out.result = _srvsvc_NETRDFSFIXLOCALVOLUME(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSFIXLOCALVOLUME, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NETRDFSFIXLOCALVOLUME(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NETRDFSMANAGERREPORTSITEINFO(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSMANAGERREPORTSITEINFO r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NETRDFSMANAGERREPORTSITEINFO");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NETRDFSMANAGERREPORTSITEINFO(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSMANAGERREPORTSITEINFO, &r);
	
	r.out.result = _srvsvc_NETRDFSMANAGERREPORTSITEINFO(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSMANAGERREPORTSITEINFO, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NETRDFSMANAGERREPORTSITEINFO(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}

static BOOL api_srvsvc_NETRSERVERTRANSPORTDELEX(pipes_struct *p)
{
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct srvsvc_NETRSERVERTRANSPORTDELEX r;
	TALLOC_CTX *mem_ctx = talloc_init("api_srvsvc_NETRSERVERTRANSPORTDELEX");
	
	if (!prs_data_blob(&p->in_data.data, &blob, mem_ctx)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, mem_ctx);
	if (pull == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = ndr_pull_srvsvc_NETRSERVERTRANSPORTDELEX(pull, NDR_IN, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(srvsvc_NETRSERVERTRANSPORTDELEX, &r);
	
	r.out.result = _srvsvc_NETRSERVERTRANSPORTDELEX(p);
	
	if (p->rng_fault_state) {
		talloc_free(mem_ctx);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRSERVERTRANSPORTDELEX, &r);
	
	push = ndr_push_init_ctx(mem_ctx);
	if (push == NULL) {
		talloc_free(mem_ctx);
		return False;
	}
	
	status = ndr_push_srvsvc_NETRSERVERTRANSPORTDELEX(push, NDR_OUT, &r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(mem_ctx);
		return False;
	}
	
	talloc_free(mem_ctx);
	
	return True;
}


/* Tables */
static struct api_struct api_srvsvc_cmds[] = 
{
	{"SRVSVC_NETCHARDEVENUM", DCERPC_SRVSVC_NETCHARDEVENUM, api_srvsvc_NetCharDevEnum},
	{"SRVSVC_NETCHARDEVGETINFO", DCERPC_SRVSVC_NETCHARDEVGETINFO, api_srvsvc_NetCharDevGetInfo},
	{"SRVSVC_NETCHARDEVCONTROL", DCERPC_SRVSVC_NETCHARDEVCONTROL, api_srvsvc_NetCharDevControl},
	{"SRVSVC_NETCHARDEVQENUM", DCERPC_SRVSVC_NETCHARDEVQENUM, api_srvsvc_NetCharDevQEnum},
	{"SRVSVC_NETCHARDEVQGETINFO", DCERPC_SRVSVC_NETCHARDEVQGETINFO, api_srvsvc_NetCharDevQGetInfo},
	{"SRVSVC_NETCHARDEVQSETINFO", DCERPC_SRVSVC_NETCHARDEVQSETINFO, api_srvsvc_NetCharDevQSetInfo},
	{"SRVSVC_NETCHARDEVQPURGE", DCERPC_SRVSVC_NETCHARDEVQPURGE, api_srvsvc_NetCharDevQPurge},
	{"SRVSVC_NETCHARDEVQPURGESELF", DCERPC_SRVSVC_NETCHARDEVQPURGESELF, api_srvsvc_NetCharDevQPurgeSelf},
	{"SRVSVC_NETCONNENUM", DCERPC_SRVSVC_NETCONNENUM, api_srvsvc_NetConnEnum},
	{"SRVSVC_NETFILEENUM", DCERPC_SRVSVC_NETFILEENUM, api_srvsvc_NetFileEnum},
	{"SRVSVC_NETFILEGETINFO", DCERPC_SRVSVC_NETFILEGETINFO, api_srvsvc_NetFileGetInfo},
	{"SRVSVC_NETFILECLOSE", DCERPC_SRVSVC_NETFILECLOSE, api_srvsvc_NetFileClose},
	{"SRVSVC_NETSESSENUM", DCERPC_SRVSVC_NETSESSENUM, api_srvsvc_NetSessEnum},
	{"SRVSVC_NETSESSDEL", DCERPC_SRVSVC_NETSESSDEL, api_srvsvc_NetSessDel},
	{"SRVSVC_NETSHAREADD", DCERPC_SRVSVC_NETSHAREADD, api_srvsvc_NetShareAdd},
	{"SRVSVC_NETSHAREENUMALL", DCERPC_SRVSVC_NETSHAREENUMALL, api_srvsvc_NetShareEnumAll},
	{"SRVSVC_NETSHAREGETINFO", DCERPC_SRVSVC_NETSHAREGETINFO, api_srvsvc_NetShareGetInfo},
	{"SRVSVC_NETSHARESETINFO", DCERPC_SRVSVC_NETSHARESETINFO, api_srvsvc_NetShareSetInfo},
	{"SRVSVC_NETSHAREDEL", DCERPC_SRVSVC_NETSHAREDEL, api_srvsvc_NetShareDel},
	{"SRVSVC_NETSHAREDELSTICKY", DCERPC_SRVSVC_NETSHAREDELSTICKY, api_srvsvc_NetShareDelSticky},
	{"SRVSVC_NETSHARECHECK", DCERPC_SRVSVC_NETSHARECHECK, api_srvsvc_NetShareCheck},
	{"SRVSVC_NETSRVGETINFO", DCERPC_SRVSVC_NETSRVGETINFO, api_srvsvc_NetSrvGetInfo},
	{"SRVSVC_NETSRVSETINFO", DCERPC_SRVSVC_NETSRVSETINFO, api_srvsvc_NetSrvSetInfo},
	{"SRVSVC_NETDISKENUM", DCERPC_SRVSVC_NETDISKENUM, api_srvsvc_NetDiskEnum},
	{"SRVSVC_NETSERVERSTATISTICSGET", DCERPC_SRVSVC_NETSERVERSTATISTICSGET, api_srvsvc_NetServerStatisticsGet},
	{"SRVSVC_NETTRANSPORTADD", DCERPC_SRVSVC_NETTRANSPORTADD, api_srvsvc_NetTransportAdd},
	{"SRVSVC_NETTRANSPORTENUM", DCERPC_SRVSVC_NETTRANSPORTENUM, api_srvsvc_NetTransportEnum},
	{"SRVSVC_NETTRANSPORTDEL", DCERPC_SRVSVC_NETTRANSPORTDEL, api_srvsvc_NetTransportDel},
	{"SRVSVC_NETREMOTETOD", DCERPC_SRVSVC_NETREMOTETOD, api_srvsvc_NetRemoteTOD},
	{"SRVSVC_NETSETSERVICEBITS", DCERPC_SRVSVC_NETSETSERVICEBITS, api_srvsvc_NetSetServiceBits},
	{"SRVSVC_NETPATHTYPE", DCERPC_SRVSVC_NETPATHTYPE, api_srvsvc_NetPathType},
	{"SRVSVC_NETPATHCANONICALIZE", DCERPC_SRVSVC_NETPATHCANONICALIZE, api_srvsvc_NetPathCanonicalize},
	{"SRVSVC_NETPATHCOMPARE", DCERPC_SRVSVC_NETPATHCOMPARE, api_srvsvc_NetPathCompare},
	{"SRVSVC_NETNAMEVALIDATE", DCERPC_SRVSVC_NETNAMEVALIDATE, api_srvsvc_NetNameValidate},
	{"SRVSVC_NETRPRNAMECANONICALIZE", DCERPC_SRVSVC_NETRPRNAMECANONICALIZE, api_srvsvc_NETRPRNAMECANONICALIZE},
	{"SRVSVC_NETPRNAMECOMPARE", DCERPC_SRVSVC_NETPRNAMECOMPARE, api_srvsvc_NetPRNameCompare},
	{"SRVSVC_NETSHAREENUM", DCERPC_SRVSVC_NETSHAREENUM, api_srvsvc_NetShareEnum},
	{"SRVSVC_NETSHAREDELSTART", DCERPC_SRVSVC_NETSHAREDELSTART, api_srvsvc_NetShareDelStart},
	{"SRVSVC_NETSHAREDELCOMMIT", DCERPC_SRVSVC_NETSHAREDELCOMMIT, api_srvsvc_NetShareDelCommit},
	{"SRVSVC_NETGETFILESECURITY", DCERPC_SRVSVC_NETGETFILESECURITY, api_srvsvc_NetGetFileSecurity},
	{"SRVSVC_NETSETFILESECURITY", DCERPC_SRVSVC_NETSETFILESECURITY, api_srvsvc_NetSetFileSecurity},
	{"SRVSVC_NETSERVERTRANSPORTADDEX", DCERPC_SRVSVC_NETSERVERTRANSPORTADDEX, api_srvsvc_NetServerTransportAddEx},
	{"SRVSVC_NETSERVERSETSERVICEBITSEX", DCERPC_SRVSVC_NETSERVERSETSERVICEBITSEX, api_srvsvc_NetServerSetServiceBitsEx},
	{"SRVSVC_NETRDFSGETVERSION", DCERPC_SRVSVC_NETRDFSGETVERSION, api_srvsvc_NETRDFSGETVERSION},
	{"SRVSVC_NETRDFSCREATELOCALPARTITION", DCERPC_SRVSVC_NETRDFSCREATELOCALPARTITION, api_srvsvc_NETRDFSCREATELOCALPARTITION},
	{"SRVSVC_NETRDFSDELETELOCALPARTITION", DCERPC_SRVSVC_NETRDFSDELETELOCALPARTITION, api_srvsvc_NETRDFSDELETELOCALPARTITION},
	{"SRVSVC_NETRDFSSETLOCALVOLUMESTATE", DCERPC_SRVSVC_NETRDFSSETLOCALVOLUMESTATE, api_srvsvc_NETRDFSSETLOCALVOLUMESTATE},
	{"SRVSVC_NETRDFSSETSERVERINFO", DCERPC_SRVSVC_NETRDFSSETSERVERINFO, api_srvsvc_NETRDFSSETSERVERINFO},
	{"SRVSVC_NETRDFSCREATEEXITPOINT", DCERPC_SRVSVC_NETRDFSCREATEEXITPOINT, api_srvsvc_NETRDFSCREATEEXITPOINT},
	{"SRVSVC_NETRDFSDELETEEXITPOINT", DCERPC_SRVSVC_NETRDFSDELETEEXITPOINT, api_srvsvc_NETRDFSDELETEEXITPOINT},
	{"SRVSVC_NETRDFSMODIFYPREFIX", DCERPC_SRVSVC_NETRDFSMODIFYPREFIX, api_srvsvc_NETRDFSMODIFYPREFIX},
	{"SRVSVC_NETRDFSFIXLOCALVOLUME", DCERPC_SRVSVC_NETRDFSFIXLOCALVOLUME, api_srvsvc_NETRDFSFIXLOCALVOLUME},
	{"SRVSVC_NETRDFSMANAGERREPORTSITEINFO", DCERPC_SRVSVC_NETRDFSMANAGERREPORTSITEINFO, api_srvsvc_NETRDFSMANAGERREPORTSITEINFO},
	{"SRVSVC_NETRSERVERTRANSPORTDELEX", DCERPC_SRVSVC_NETRSERVERTRANSPORTDELEX, api_srvsvc_NETRSERVERTRANSPORTDELEX},
};

void srvsvc_get_pipe_fns(struct api_struct **fns, int *n_fns)
{
	*fns = api_srvsvc_cmds;
	*n_fns = sizeof(api_srvsvc_cmds) / sizeof(struct api_struct);
}

NTSTATUS rpc_srvsvc_init(void)
{
	return rpc_pipe_register_commands(SMB_RPC_INTERFACE_VERSION, "srvsvc", "srvsvc", api_srvsvc_cmds, sizeof(api_srvsvc_cmds) / sizeof(struct api_struct));
}
