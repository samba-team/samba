#!/usr/bin/env python

srcdir=".."

import sys, os
from optparse import SUPPRESS_HELP
sys.path.insert(0, srcdir+"/buildtools/wafsamba")
sys.path.insert(0, "source3")
import wafsamba, Options, Logs, Utils, Scripting
import build.charset
import samba_utils, samba_version
import samba3

Options.default_prefix = '/usr/local/samba'

def set_options(opt):

    opt.add_option('--with-static-modules',
                   help=("Comma-separated list of names of modules to statically link in"),
                   action="store", dest='static_modules', default=None)
    opt.add_option('--with-shared-modules',
                   help=("Comma-separated list of names of modules to build shared"),
                   action="store", dest='shared_modules', default=None)

    opt.SAMBA3_ADD_OPTION('winbind')
    opt.SAMBA3_ADD_OPTION('ads')
    opt.SAMBA3_ADD_OPTION('ldap')
    opt.SAMBA3_ADD_OPTION('cups', with_name="enable", without_name="disable")
    opt.SAMBA3_ADD_OPTION('iprint', with_name="enable", without_name="disable")
    opt.SAMBA3_ADD_OPTION('pam')
    opt.SAMBA3_ADD_OPTION('pam_smbpass')
    opt.SAMBA3_ADD_OPTION('quotas')
    opt.SAMBA3_ADD_OPTION('sendfile-support')
    opt.SAMBA3_ADD_OPTION('utmp')
    opt.SAMBA3_ADD_OPTION('pthreadpool', with_name="enable", without_name="disable", default=True)
    opt.SAMBA3_ADD_OPTION('avahi', with_name="enable", without_name="disable")
    opt.SAMBA3_ADD_OPTION('iconv')
    opt.SAMBA3_ADD_OPTION('acl-support')
    opt.SAMBA3_ADD_OPTION('dnsupdate')
    opt.SAMBA3_ADD_OPTION('syslog')
    opt.SAMBA3_ADD_OPTION('automount')
    opt.SAMBA3_ADD_OPTION('aio-support')
    opt.SAMBA3_ADD_OPTION('dmapi', default=None) # None means autodetection
    opt.SAMBA3_ADD_OPTION('fam', default=None) # None means autodetection
    opt.SAMBA3_ADD_OPTION('profiling-data', default=False)
    opt.SAMBA3_ADD_OPTION('libarchive', default=None)

    opt.SAMBA3_ADD_OPTION('cluster-support', default=None)

    opt.SAMBA3_ADD_OPTION('regedit', default=None)

    opt.SAMBA3_ADD_OPTION('fake-kaserver',
                          help=("Include AFS fake-kaserver support"), default=False)

    opt.add_option('--with-libcephfs',
                   help=("Directory under which libcephfs is installed"),
                   action="store", dest='libcephfs_dir', default=None)

    opt.SAMBA3_ADD_OPTION('glusterfs', with_name="enable", without_name="disable", default=True)

    opt.add_option('--enable-vxfs',
                  help=("enable support for VxFS (default=no)"),
                  action="store_true", dest='enable_vxfs', default=False)


def configure(conf):
    from samba_utils import TO_LIST

    default_static_modules = []
    default_shared_modules = []

    if Options.options.developer:
        conf.ADD_CFLAGS('-DDEVELOPER -DDEBUG_PASSWORD')
        conf.env.developer = True

    if sys.platform != 'openbsd5':
        conf.ADD_LDFLAGS("-Wl,--export-dynamic", testflags=True)

    conf.CHECK_HEADERS('execinfo.h libexc.h libunwind.h netdb.h')
    conf.CHECK_HEADERS('linux/falloc.h linux/ioctl.h')

    conf.CHECK_FUNCS('getcwd fchown chmod fchmod mknod')
    conf.CHECK_FUNCS('strtol strchr strupr chflags')
    conf.CHECK_FUNCS('getrlimit fsync fdatasync setpgid')
    conf.CHECK_FUNCS('setsid glob strpbrk crypt16 getauthuid')
    conf.CHECK_FUNCS('sigprocmask sigblock sigaction sigset innetgr')
    conf.CHECK_FUNCS('initgroups select poll rdchk getgrnam getgrent pathconf')
    conf.CHECK_FUNCS('setpriv setgidx setuidx setgroups syscall sysconf')
    conf.CHECK_FUNCS('atexit grantpt posix_openpt fallocate posix_fallocate')
    conf.CHECK_FUNCS('fseeko setluid')
    conf.CHECK_FUNCS('getpwnam', headers='sys/types.h pwd.h')
    conf.CHECK_FUNCS('fdopendir')
    conf.CHECK_FUNCS('fstatat')
    conf.CHECK_FUNCS('getpwent_r setenv strcasecmp fcvt fcvtl')
    conf.CHECK_FUNCS('syslog vsyslog timegm setlocale')
    conf.CHECK_FUNCS_IN('nanosleep', 'rt')
    conf.CHECK_FUNCS('lutimes futimes utimensat futimens')
    conf.CHECK_FUNCS('mlock munlock mlockall munlockall')
    conf.CHECK_FUNCS('memalign posix_memalign hstrerror')
    conf.CHECK_FUNCS('shmget')
    conf.CHECK_FUNCS_IN('shm_open', 'rt', checklibc=True)
    #FIXME: for some reason this one still fails
    conf.CHECK_FUNCS_IN('yp_get_default_domain', 'nsl')
    conf.CHECK_FUNCS_IN('dn_expand _dn_expand __dn_expand', 'resolv')
    conf.CHECK_FUNCS_IN('dn_expand', 'inet')
    conf.CHECK_DECLS('fdatasync', reverse=True)
    conf.CHECK_DECLS('readahead', reverse=True, headers='fcntl.h')

    if conf.CHECK_CODE('''
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
long ret = splice(0,0,1,0,400,SPLICE_F_MOVE);
''',
        'HAVE_LINUX_SPLICE',
        headers='fcntl.h'):
        conf.CHECK_DECLS('splice', reverse=True, headers='fcntl.h')

    # Check for inotify support
    conf.CHECK_HEADERS('sys/inotify.h')
    if "HAVE_SYS_INOTIFY_H" in conf.env:
        conf.DEFINE('HAVE_INOTIFY', 1)

    # Check for kernel change notify support
    conf.CHECK_CODE('''
#ifndef F_NOTIFY
#define F_NOTIFY 1026
#endif
main() {
        exit(fcntl(open("/tmp", O_RDONLY), F_NOTIFY, 0) == -1 ?  1 : 0);
}''', 'HAVE_KERNEL_CHANGE_NOTIFY', addmain=False, execute=True,
        headers='fcntl.h signal.h',
        msg="Checking for kernel change notify support")

    # Check for Linux kernel oplocks
    conf.CHECK_CODE('''
#include <sys/types.h>
#include <fcntl.h>
#include <signal.h>
#ifndef F_NOTIFY
#define F_NOTIFY 1026
#endif
main() {
        exit(fcntl(open("/tmp", O_RDONLY), F_NOTIFY, 0) == -1 ?  1 : 0);
}''', 'HAVE_KERNEL_OPLOCKS_LINUX', addmain=False, execute=True,
        msg="Checking for Linux kernel oplocks")

    # Check for IRIX kernel oplock types
    conf.CHECK_CODE('oplock_stat_t t; t.os_state = OP_REVOKE; t.os_dev = 1; t.os_ino = 1;',
                    'HAVE_KERNEL_OPLOCKS_IRIX', headers='fcntl.h',
                    msg="Checking for IRIX kernel oplock types")

    # Check for kernel share modes
    conf.CHECK_CODE('''
#include <sys/types.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/file.h>
#ifndef LOCK_MAND
#define LOCK_MAND        32
#define LOCK_READ        64
#endif
main() {
        exit(flock(open("/dev/null", O_RDWR), LOCK_MAND|LOCK_READ) != 0);
}''', 'HAVE_KERNEL_SHARE_MODES', addmain=False, execute=True,
        msg="Checking for kernel share modes")

    # check for fam libs
    samba_fam_libs=None
    check_for_fam=False
    if Options.options.with_fam is None:
        check_for_fam=True
    elif Options.options.with_fam == True:
        check_for_fam=True

    if check_for_fam and conf.CHECK_HEADERS('fam.h'):
        if conf.CHECK_FUNCS_IN('FAMOpen2', 'fam'):
            samba_fam_libs='fam'
        elif conf.CHECK_FUNCS_IN('FAMOpen2', 'fam C'):
            samba_fam_libs='fam C'
        conf.CHECK_TYPE('enum FAMCodes', headers='fam.h',
            define='HAVE_FAM_H_FAMCODES_TYPEDEF',
            msg='Checking whether enum FAMCodes is available')
        conf.CHECK_FUNCS_IN('FAMNoExists', 'fam')

    if samba_fam_libs is not None:
        conf.DEFINE('SAMBA_FAM_LIBS', samba_fam_libs)
    else:
        if Options.options.with_fam == True:
            conf.fatal('FAM support requested, but no suitable FAM library found')
        elif check_for_fam:
            Logs.warn('no suitable FAM library found')

    # check for libarchive (tar command in smbclient)
    # None means autodetect, True/False means enable/disable
    conf.env['archive_lib'] = ''
    if Options.options.with_libarchive is not False:
        libarchive_mandatory = Options.options.with_libarchive == True
        Logs.info("Checking for libarchive existence")
        if conf.CHECK_BUNDLED_SYSTEM('libarchive', minversion='3.1.2'):
            conf.env['archive_lib'] = 'libarchive'
        elif libarchive_mandatory:
            conf.fatal('libarchive support requested, but no suitable pkgconfig found')

    # check for DMAPI libs
    if Options.options.with_dmapi == False:
        have_dmapi = False
    else:
        have_dmapi = True
        Logs.info("Checking for DMAPI library existence")
        samba_dmapi_lib = ''
        if conf.CHECK_FUNCS_IN('dm_get_eventlist', 'dm'):
            samba_dmapi_lib = 'dm'
        else:
            if conf.CHECK_FUNCS_IN('dm_get_eventlist', 'jfsdm'):
                samba_dmapi_lib = 'jfsdm'
            else:
                if conf.CHECK_FUNCS_IN('dm_get_eventlist', 'dmapi'):
                    samba_dmapi_lib = 'dmapi'
                else:
                    if conf.CHECK_FUNCS_IN('dm_get_eventlist', 'xdsm'):
                        samba_dmapi_lib = 'xdsm'
        # only bother to test headers and compilation when a candidate
        # library has been found
        if samba_dmapi_lib == '':
            have_dmapi = False
            broken_dmapi = "no suitable DMAPI library found"

        if have_dmapi:
            conf.CHECK_HEADERS('sys/dmi.h xfs/dmapi.h sys/jfsdmapi.h sys/dmapi.h dmapi.h')
            conf.CHECK_CODE('''
#include <time.h>      /* needed by Tru64 */
#include <sys/types.h> /* needed by AIX */
#ifdef HAVE_XFS_DMAPI_H
#include <xfs/dmapi.h>
#elif defined(HAVE_SYS_DMI_H)
#include <sys/dmi.h>
#elif defined(HAVE_SYS_JFSDMAPI_H)
#include <sys/jfsdmapi.h>
#elif defined(HAVE_SYS_DMAPI_H)
#include <sys/dmapi.h>
#elif defined(HAVE_DMAPI_H)
#include <dmapi.h>
#endif

/* This link test is designed to fail on IRI 6.4, but should
 * succeed on Linux, IRIX 6.5 and AIX.
 */
int main(int argc, char **argv)
{
	char * version;
	dm_eventset_t events;
	/* This doesn't take an argument on IRIX 6.4. */
	dm_init_service(&version);
	/* IRIX 6.4 expects events to be a pointer. */
	DMEV_ISSET(DM_EVENT_READ, events);

	return 0;
}
''',
            'USEABLE_DMAPI_LIBRARY',
            addmain=False,
            execute=False,
            lib=samba_dmapi_lib,
            msg='Checking whether DMAPI lib '+samba_dmapi_lib+' can be used')
            if not conf.CONFIG_SET('USEABLE_DMAPI_LIBRARY'):
                have_dmapi = False
                broken_dmapi = "no usable DMAPI library found"

    if have_dmapi:
        Logs.info("Building with DMAPI support.")
        conf.env['dmapi_lib'] = samba_dmapi_lib
        conf.DEFINE('USE_DMAPI', 1)
    else:
        if Options.options.with_dmapi == False:
            Logs.info("Building without DMAPI support (--without-dmapi).")
        elif Options.options.with_dmapi == True:
            Logs.error("DMAPI support not available: " + broken_dmapi)
            conf.fatal('DMAPI support requested but not found.');
        else:
            Logs.warn("Building without DMAPI support: " + broken_dmapi)
        conf.env['dmapi_lib'] = ''

    # Check for various members of the stat structure
    conf.CHECK_STRUCTURE_MEMBER('struct stat', 'st_blocks', define='HAVE_STAT_ST_BLOCKS',
                                headers='sys/stat.h')
    conf.CHECK_STRUCTURE_MEMBER('struct stat', 'st_blksize', define='HAVE_STAT_ST_BLKSIZE',
                                headers='sys/stat.h')
    conf.CHECK_STRUCTURE_MEMBER('struct stat', 'st_flags', define='HAVE_STAT_ST_FLAGS',
                                headers='sys/types.h sys/stat.h unistd.h')

    if "HAVE_BLKCNT_T" in conf.env:
        conf.CHECK_CODE('''
        static int test_array[1 - 2 * !(((long int)(sizeof(blkcnt_t))) <= 4)];''',
                'SIZEOF_BLKCNT_T_4',
                headers='replace.h sys/types.h sys/stat.h unistd.h',
                msg="Checking whether blkcnt_t is 32 bit")

    # If sizeof is 4 it can't be 8
    if "HAVE_BLKCNT_T" in conf.env:
        if not conf.CONFIG_SET('SIZEOF_BLKCNT_T_4'):
            conf.CHECK_CODE('''
            static int test_array[1 - 2 * !(((long int)(sizeof(blkcnt_t))) <= 8)];''',
                    'SIZEOF_BLKCNT_T_8',
                    headers='replace.h sys/types.h sys/stat.h unistd.h',
                    msg="Checking whether blkcnt_t is 64 bit")

    # Check for POSIX capability support
    conf.CHECK_FUNCS_IN('cap_get_proc', 'cap', headers='sys/capability.h')

    if "HAVE_SYS_CAPABILITY_H" in conf.env:
        conf.CHECK_CODE('''
        cap_t cap;
        cap_value_t vals[1];
        if (!(cap = cap_get_proc())) exit(1);
        vals[0] = CAP_CHOWN;
        cap_set_flag(cap, CAP_INHERITABLE, 1, vals, CAP_CLEAR);
        cap_set_proc(cap);''',
                        'HAVE_POSIX_CAPABILITIES', execute=True, lib="cap",
                        headers='sys/capability.h',
                        msg="Checking whether POSIX capabilities are available")

    # Check for int16, uint16, int32 and uint32 in rpc/types.h included from
    # rpc/rpc.h. This is *really* broken but some systems (DEC OSF1) do this.
    # -- JRA.
    if conf.CONFIG_SET("HAVE_RPC_RPC_H"):
        conf.CHECK_TYPE('int16', headers='rpc/rpc.h',
                        define='HAVE_INT16_FROM_RPC_RPC_H',
                        msg="Checking for int16 typedef included by rpc/rpc.h")
        conf.CHECK_CODE('uint16 testvar;', 'HAVE_INT16_FROM_RPC_RPC_H',
                        headers='sys/types.h rpc/rpc.h',
                        msg="Checking for uint16 typedef included by rpc/rpc.h")
        conf.CHECK_CODE('int32 testvar;', 'HAVE_INT16_FROM_RPC_RPC_H',
                        headers='sys/types.h rpc/rpc.h',
                        msg="Checking for int32 typedef included by rpc/rpc.h")
        conf.CHECK_CODE('uint32 testvar;', 'HAVE_INT16_FROM_RPC_RPC_H',
                        headers='sys/types.h rpc/rpc.h',
                        msg="Checking for uint32 typedef included by rpc/rpc.h")
    conf.CHECK_CODE('int i;', 'BROKEN_NISPLUS_INCLUDE_FILES',
                    headers='sys/types.h sys/acl.h rpcsvc/nis.h',
                    msg="Checking for broken nisplus include files")

    # Check if the compiler will optimize out functions
    conf.CHECK_CODE('''
if (0) {
    this_function_does_not_exist();
} else {
    return 1;
}''', 'HAVE_COMPILER_WILL_OPTIMIZE_OUT_FNS',
        msg="Checking if the compiler will optimize out functions")

    # Check if the compiler supports the LL suffix on long long integers
    # AIX needs this
    conf.CHECK_CODE('long long i = 0x8000000000LL', 'COMPILER_SUPPORTS_LL',
                    headers='stdio.h',
                    msg="Checking for LL suffix on long long integers")

    conf.CHECK_FUNCS('''
_acl __acl atexit 
 _chdir __chdir chflags chmod _close __close _closedir
__closedir crypt16 devnm dirfd
DNSServiceRegister _dup __dup _dup2 __dup2 endmntent execl
_facl __facl _fchdir
__fchdir fchmod fchown _fcntl __fcntl fcvt fcvtl fdatasync
_fork __fork fseeko
fsetxattr _fstat __fstat fsync
futimens futimes __fxstat getauthuid
getcwd _getcwd __getcwd getdents __getdents getdirentries
getgrent getgrnam getgrouplist getgrset getmntent getpagesize
getpwanam getpwent_r getrlimit
glob grantpt hstrerror initgroups innetgr
llseek _llseek __llseek _lseek __lseek
_lstat __lstat lutimes
__lxstat memalign mknod mlock mlockall munlock munlockall
_open __open _opendir __opendir
pathconf poll posix_fallocate
posix_memalign pread _pread __pread
pwrite _pwrite __pwrite
rdchk _read __read _readdir __readdir
_seekdir __seekdir
select setenv setgidx setgroups setlocale setluid
setmntent setpgid setpriv setsid setuidx
shmget shm_open sigaction sigblock sigprocmask sigset
_stat __stat statvfs
strcasecmp strchr strpbrk strsignal strtol strupr sysconf sysctl sysctlbyname
__sys_llseek syslog _telldir __telldir timegm
utimensat vsyslog _write __write __xstat
''')

    conf.CHECK_SAMBA3_CHARSET() # see build/charset.py

    # FIXME: these should be tests for features, but the old build system just
    # checks for OSes.
    host_os = sys.platform
    Logs.info("building on %s" % host_os)

    # Python doesn't have case switches... :/
    # FIXME: original was *linux* | gnu* | k*bsd*-gnu | kopensolaris*-gnu | *qnx*)
    # the search for .rfind('gnu') covers gnu* and *-gnu is that too broad?

    conf.SET_TARGET_TYPE('sunacl', 'EMPTY')
    if (host_os.rfind('linux') > -1) or (host_os.rfind('gnu') > -1) or (host_os.rfind('qnx') > -1):
        if host_os.rfind('linux') > -1:
            conf.DEFINE('LINUX', '1')
        elif host_os.rfind('qnx') > -1:
            conf.DEFINE('QNX', '1')
        conf.DEFINE('STAT_ST_BLOCKSIZE', '512')
    elif (host_os.rfind('darwin') > -1):
        conf.DEFINE('DARWINOS', 1)
        conf.ADD_CFLAGS('-fno-common')
        conf.DEFINE('STAT_ST_BLOCKSIZE', '512')
    elif (host_os.rfind('freebsd') > -1):
        conf.DEFINE('FREEBSD', 1)
        if conf.CHECK_HEADERS('sunacl.h'):
            conf.DEFINE('HAVE_FREEBSD_SUNACL_H', '1')
            conf.CHECK_FUNCS_IN(['acl'], 'sunacl')
        conf.DEFINE('STAT_ST_BLOCKSIZE', '512')
    elif (host_os.rfind('irix') > -1):
        conf.DEFINE('IRIX', 1)
        conf.DEFINE('STAT_ST_BLOCKSIZE', '512')
    elif (host_os.rfind('aix') > -1):
        conf.DEFINE('AIX', 1)
        conf.DEFINE('STAT_ST_BLOCKSIZE', 'DEV_BSIZE')
    elif (host_os.rfind('hpux') > -1):
        conf.DEFINE('HPUX', 1)
        conf.DEFINE('STAT_ST_BLOCKSIZE', '8192')
    elif (host_os.rfind('osf') > -1):
        conf.DEFINE('OSF1', 1)
        conf.DEFINE('STAT_ST_BLOCKSIZE', '512')

    # FIXME: Add more checks here.
    else:
        conf.DEFINE('STAT_ST_BLOCKSIZE', '512')

    if Options.options.with_acl_support:
        if (host_os.rfind('hpux') > -1):
		Logs.info('Using HPUX ACLs')
                conf.DEFINE('HAVE_HPUX_ACLS',1)
                conf.DEFINE('POSIX_ACL_NEEDS_MASK',1)
                default_static_modules.extend(TO_LIST('vfs_hpuxacl'))
	elif (host_os.rfind('aix') > -1):
		Logs.info('Using AIX ACLs')
                conf.DEFINE('HAVE_AIX_ACLS',1)
                default_static_modules.extend(TO_LIST('vfs_aixacl vfs_aixacl2'))
        elif (host_os.rfind('darwin') > -1):
            Logs.warn('ACLs on Darwin currently not supported')
            conf.fatal("ACL support not available on Darwin/MacOS. "
                       "Use --without-acl-support for building without "
                       "ACL support. "
                       "ACL support is required to change permissions "
                       "from Windows clients.")
        else:
            conf.CHECK_FUNCS_IN(['acl_get_file'], 'acl')
            if conf.CHECK_CODE('''
acl_t acl;
int entry_id;
acl_entry_t *entry_p;
return acl_get_entry(acl, entry_id, entry_p);
''',
                        'HAVE_POSIX_ACLS',
                        headers='sys/types.h sys/acl.h', link=False,
                        msg="Checking for POSIX ACL support") :
                conf.CHECK_CODE('''
acl_permset_t permset_d;
acl_perm_t perm;
return acl_get_perm_np(permset_d, perm);
''',
                        'HAVE_ACL_GET_PERM_NP',
                        headers='sys/types.h sys/acl.h', link=True,
                        msg="Checking whether acl_get_perm_np() is available")
                default_static_modules.extend(TO_LIST('vfs_posixacl'))
            elif conf.CHECK_FUNCS_IN(['facl'], 'sec'):
                Logs.info('Using solaris or UnixWare ACLs')
                conf.DEFINE('HAVE_SOLARIS_UNIXWARE_ACLS',1)
                default_static_modules.extend(TO_LIST('vfs_solarisacl'))
            elif conf.CHECK_FUNCS_IN(['acl_get_fd'], 'pacl'):
                Logs.info('Using Tru64 ACLs')
                conf.DEFINE('HAVE_TRU64_ACLS',1)
                default_static_modules.extend(TO_LIST('vfs_tru64acl'))
            else:
                conf.fatal("ACL support not found. Try installing libacl1-dev "
                           "or libacl-devel.  "
                           "Otherwise, use --without-acl-support to build "
                           "without ACL support. "
                           "ACL support is required to change permissions from "
                           "Windows clients.")

    if conf.CHECK_FUNCS('dirfd'):
        conf.DEFINE('HAVE_DIRFD_DECL', 1)

    conf.CHECK_CODE('struct statfs fsd; fsid_t fsid = fsd.f_fsid; return statfs(".", &fsd);',
                    'HAVE_STATFS_F_FSID',
                    msg="vfs_fileid checking for statfs() and struct statfs.f_fsid",
                    headers='sys/types.h sys/statfs.h',
                    execute=True)

    if conf.CONFIG_SET('HAVE_FALLOCATE'):
        conf.CHECK_CODE('''
                int ret = fallocate(0, FALLOC_FL_KEEP_SIZE, 0, 10);''',
                'HAVE_LINUX_FALLOCATE',
                msg="Checking whether the Linux 'fallocate' function is available",
                headers='unistd.h sys/types.h fcntl.h linux/falloc.h')
    conf.CHECK_CODE('''
                ssize_t err = readahead(0,0,0x80000);''',
                'HAVE_LINUX_READAHEAD',
                msg="Checking whether Linux readahead is available",
                headers='unistd.h fcntl.h')
    conf.CHECK_DECLS('readahead', headers='fcntl.h', always=True)

    conf.CHECK_CODE('int fd = openat(AT_FDCWD, ".", O_RDONLY);',
		'HAVE_OPENAT',
		msg='Checking for openat',
		headers='fcntl.h')

    if Options.options.with_aio_support:
        conf.CHECK_FUNCS_IN('aio_read', 'aio')
        conf.CHECK_FUNCS_IN('aio_read', 'rt')
        conf.CHECK_CODE('struct aiocb a; return aio_read(&a);',
                        'HAVE_AIO',
                        msg='Checking for asynchronous io support',
                        headers='sys/types.h aio.h',
                        lib='aio rt')
        if conf.CONFIG_SET('HAVE_AIO'):
            conf.CHECK_CODE('struct aiocb a; return aio_read(&a);', 'HAVE_AIO_READ', msg='Checking for aio_read', headers='aio.h', lib='aio rt')
            conf.CHECK_CODE('struct aiocb a; return aio_write(&a);', 'HAVE_AIO_WRITE', msg='Checking for aio_write', headers='aio.h', lib='aio rt')
            conf.CHECK_CODE('struct aiocb a; return aio_fsync(1, &a);', 'HAVE_AIO_FSYNC', msg='Checking for aio_fsync', headers='aio.h', lib='aio rt')
            conf.CHECK_CODE('struct aiocb a; return aio_return(&a);', 'HAVE_AIO_RETURN', msg='Checking for aio_return', headers='aio.h', lib='aio rt')
            conf.CHECK_CODE('struct aiocb a; return aio_error(&a);', 'HAVE_AIO_ERROR', msg='Checking for aio_error', headers='aio.h', lib='aio rt')
            conf.CHECK_CODE('struct aiocb a; return aio_cancel(1, &a);', 'HAVE_AIO_CANCEL', msg='Checking for aio_cancel', headers='aio.h', lib='aio rt')
            conf.CHECK_CODE('const struct aiocb * const a[1]; struct timespec t; return aio_suspend(&a, 1, &t);', 'HAVE_AIO_SUSPEND', msg='Checking for aio_suspend', headers='aio.h', lib='aio rt')
        if not conf.CONFIG_SET('HAVE_AIO'):
            conf.DEFINE('HAVE_NO_AIO', '1')
    else:
        conf.DEFINE('HAVE_NO_AIO', '1')

    if host_os.rfind('linux') > -1:
	conf.CHECK_FUNCS_IN('io_submit', 'aio')
	conf.CHECK_CODE('''
struct io_event ioev;
struct iocb *ioc;
io_context_t ctx;
struct timespec ts;
int fd;
char *buf;
fd = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);
io_queue_init(128,&ctx);
io_prep_pwrite(ioc, 1, buf, 1, 0);
io_prep_pread(ioc, 1, buf, 1, 0);
io_set_eventfd(ioc, fd);
io_set_callback(ioc, (io_callback_t)(0));
io_submit(ctx, 1, &ioc);
io_getevents(ctx, 1, 1, &ioev, &ts);
''',
			'HAVE_LINUX_KERNEL_AIO',
			msg='Checking for linux kernel asynchronous io support',
			headers='unistd.h stdlib.h sys/types.h fcntl.h sys/eventfd.h libaio.h',
			lib='aio')

    conf.CHECK_CODE('''
struct msghdr msg;
union {
        struct cmsghdr cm;
        char control[CMSG_SPACE(sizeof(int))];
} control_un;
msg.msg_control = control_un.control;
msg.msg_controllen = sizeof(control_un.control);
''',
        'HAVE_STRUCT_MSGHDR_MSG_CONTROL',
        msg='Checking if we can use msg_control for passing file descriptors',
        headers='sys/types.h stdlib.h stddef.h sys/socket.h sys/un.h')
    conf.CHECK_CODE('''
struct msghdr msg;
int fd;
msg.msg_accrights = (caddr_t) &fd;
msg.msg_accrightslen = sizeof(fd);
''',
        'HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS',
        msg='Checking if we can use msg_accrights for passing file descriptors',
        headers='sys/types.h stdlib.h stddef.h sys/socket.h sys/un.h')

    if Options.options.with_winbind:
        conf.env.build_winbind = True
        conf.DEFINE('WITH_WINBIND', '1')

    conf.find_program('awk', var='AWK')

    conf.CHECK_HEADERS('asm/types.h')

    conf.CHECK_CODE('dev_t dev; int i = major(dev); return 0', "HAVE_DEVICE_MAJOR_FN",
                    headers='unistd.h sys/types.h',
                    msg="Checking for major macro")

    conf.CHECK_CODE('dev_t dev; int i = minor(dev); return 0', "HAVE_DEVICE_MINOR_FN",
                    headers='unistd.h sys/types.h',
                    msg="Checking for minor macro")

    conf.CHECK_STRUCTURE_MEMBER('struct dirent', 'd_off',
                                headers='unistd.h sys/types.h dirent.h',
                                define='HAVE_DIRENT_D_OFF')

    conf.CHECK_FUNCS('setnetgrent getnetgrent endnetgrent')
    if conf.CHECK_CFLAGS('-Werror-implicit-function-declaration'):
        netgrent_cflags = '-Werror-implicit-function-declaration'
    else:
        netgrent_cflags = ''
    conf.CHECK_CODE('setnetgrent("foo")', 'HAVE_SETNETGRENT_PROTOTYPE',
                    msg="Checking for setnetgrent prototype",
                    headers='netdb.h netgroup.h',
                    cflags=netgrent_cflags)
    conf.CHECK_CODE('getnetgrent', 'HAVE_GETNETGRENT_PROTOTYPE',
                    msg="Checking for getnetgrent prototype",
                    headers='netdb.h netgroup.h',
                    cflags=netgrent_cflags)
    conf.CHECK_CODE('endnetgrent', 'HAVE_ENDNETGRENT_PROTOTYPE',
                    msg="Checking for endnetgrent prototype",
                    headers='netdb.h netgroup.h',
                    cflags=netgrent_cflags)


    # Look for CUPS
    if Options.options.with_cups:
        conf.find_program('cups-config', var='CUPS_CONFIG')
        if conf.env.CUPS_CONFIG:
            # we would normally use --libs here, but cups-config incorrectly adds
            # gssapi_krb5 and other libraries to its --libs output. That breaks the use
            # of an in-tree heimdal kerberos
            conf.check_cfg(path=conf.env.CUPS_CONFIG, args="--cflags --ldflags",
                           package="", uselib_store="CUPS")
        conf.CHECK_HEADERS('cups/cups.h cups/language.h', lib='cups')
        conf.CHECK_FUNCS_IN('httpConnect httpConnectEncrypt', 'cups')
        if conf.CONFIG_SET('HAVE_CUPS_CUPS_H') and conf.CONFIG_SET('HAVE_CUPS_LANGUAGE_H'):
            conf.DEFINE('HAVE_CUPS', '1')
        else:
            conf.undefine('HAVE_CUPS')
            conf.SET_TARGET_TYPE('cups', 'EMPTY')
    else:
        # define an empty subsystem for cups, to allow it to be used as an empty dependency
        conf.SET_TARGET_TYPE('cups', 'EMPTY')

    if Options.options.with_iprint:
        if conf.CONFIG_SET('HAVE_CUPS'):
            conf.DEFINE('HAVE_IPRINT', '1')
        else:
            Logs.warn("--enable-iprint=yes but cups support not sufficient")
    if Options.options.with_syslog:
        conf.DEFINE('WITH_SYSLOG', '1')
    if Options.options.with_automount:
        conf.DEFINE('WITH_AUTOMOUNT', '1')

    # Check for LDAP
    if Options.options.with_ldap:
        conf.CHECK_HEADERS('ldap.h lber.h ldap_pvt.h')
        conf.CHECK_TYPE('ber_tag_t', 'unsigned int', headers='ldap.h lber.h')
        conf.CHECK_FUNCS_IN('ber_scanf ber_sockbuf_add_io', 'lber')
        conf.CHECK_VARIABLE('LDAP_OPT_SOCKBUF', headers='ldap.h')

        # if we LBER_OPT_LOG_PRINT_FN we can intercept ldap logging and print it out
        # for the samba logs
        conf.CHECK_VARIABLE('LBER_OPT_LOG_PRINT_FN',
                            define='HAVE_LBER_LOG_PRINT_FN', headers='lber.h')

        conf.CHECK_FUNCS_IN('ldap_init ldap_init_fd ldap_initialize ldap_set_rebind_proc', 'ldap')
        conf.CHECK_FUNCS_IN('ldap_add_result_entry', 'ldap')

        # Check if ldap_set_rebind_proc() takes three arguments
        if conf.CHECK_CODE('ldap_set_rebind_proc(0, 0, 0)',
                           'LDAP_SET_REBIND_PROC_ARGS',
                           msg="Checking whether ldap_set_rebind_proc takes 3 arguments",
                           headers='ldap.h lber.h', link=False):
            conf.DEFINE('LDAP_SET_REBIND_PROC_ARGS', '3')
        else:
            conf.DEFINE('LDAP_SET_REBIND_PROC_ARGS', '2')

        # last but not least, if ldap_init() exists, we want to use ldap
        if conf.CONFIG_SET('HAVE_LDAP_INIT') and conf.CONFIG_SET('HAVE_LDAP_H'):
            conf.DEFINE('HAVE_LDAP', '1')
            conf.DEFINE('LDAP_DEPRECATED', '1')
            conf.env['HAVE_LDAP'] = '1'
            # if ber_sockbuf_add_io() and LDAP_OPT_SOCKBUF are available, we can add
            # SASL wrapping hooks
            if conf.CONFIG_SET('HAVE_BER_SOCKBUF_ADD_IO') and \
                    conf.CONFIG_SET('HAVE_LDAP_OPT_SOCKBUF'):
                conf.DEFINE('HAVE_LDAP_SASL_WRAPPING', '1')
        else:
            conf.fatal("LDAP support not found. "
                       "Try installing libldap2-dev or openldap-devel. "
                       "Otherwise, use --without-ldap to build without "
                       "LDAP support. "
                       "LDAP support is required for the LDAP passdb backend, "
                       "LDAP idmap backends and ADS. "
                       "ADS support improves communication with "
                       "Active Directory domain controllers.")
    else:
        conf.SET_TARGET_TYPE('ldap', 'EMPTY')
        conf.SET_TARGET_TYPE('lber', 'EMPTY')

    if Options.options.with_ads == False:
        use_ads = False
        use_ads_krb5 = False
        use_ads_ldap = False
    else:
        use_ads = True
        use_ads_krb5 = True
        use_ads_ldap = True
        if not conf.CONFIG_SET('HAVE_ENCTYPE_ARCFOUR_HMAC_MD5') and \
           not conf.CONFIG_SET('HAVE_ENCTYPE_ARCFOUR_HMAC'):
            Logs.warn("arcfour-hmac-md5 encryption type not found in -lkrb5")
            use_ads_krb5 = False
        if not conf.CONFIG_SET('HAVE_KRB5_MK_REQ_EXTENDED'):
            Logs.warn("krb5_mk_req_extended not found in -lkrb5")
            use_ads_krb5 = False
        if not conf.CONFIG_SET('HAVE_KRB5_GET_HOST_REALM'):
            Logs.warn("krb5_get_host_realm not found in -lkrb5")
            use_ads_krb5 = False
        if not conf.CONFIG_SET('HAVE_KRB5_FREE_HOST_REALM'):
            Logs.warn("krb5_free_host_realm not found in -lkrb5")
            use_ads_krb5 = False
        if not conf.CONFIG_SET('HAVE_KRB5_FWD_TGT_CREDS'):
            Logs.warn("krb5_fwd_tgt_creds found in -lkrb5")
            use_ads_krb5 = False
        if not conf.CONFIG_SET('HAVE_KRB5_GET_INIT_CREDS_OPT_ALLOC'):
            Logs.warn("krb5_get_init_creds_opt_alloc not found in -lkrb5")
            use_ads_krb5 = False
        if not conf.CONFIG_SET('KRB5_CREDS_OPT_FREE_REQUIRES_CONTEXT'):
            Logs.warn("krb5_get_init_creds_opt_free was not found or was too old in -lkrb5")
            use_ads_krb5 = False
        if not conf.CONFIG_SET('HAVE_KRB5_GET_RENEWED_CREDS'):
            Logs.warn("krb5_get_renewed_creds not found in -lkrb5")
            use_ads_krb5 = False
        if not conf.CONFIG_SET('HAVE_KRB5_PRINCIPAL_COMPARE_ANY_REALM'):
            Logs.warn("krb5_principal_compare_any_realm not found in -lkrb5")
            use_ads_krb5 = False
        if not conf.CONFIG_SET('HAVE_KRB5_C_STRING_TO_KEY') and \
           not conf.CONFIG_SET('HAVE_KRB5_STRING_TO_KEY_SALT'):
            Logs.warn("krb5_c_string_to_key not found in -lkrb5")
            use_ads_krb5 = False
        if not conf.CONFIG_SET('HAVE_KRB5_PRINCIPAL2SALT') and \
           not conf.CONFIG_SET('HAVE_KRB5_GET_PW_SALT'):
            Logs.warn("no CREATE_KEY_FUNCTIONS detected")
            use_ads_krb5 = False
        if not conf.CONFIG_SET('HAVE_KRB5_GET_PERMITTED_ENCTYPES') and \
           not conf.CONFIG_SET('HAVE_KRB5_GET_DEFAULT_IN_TKT_ETYPES'):
            Logs.warn("no GET_ENCTYPES_FUNCTIONS detected")
            use_ads_krb5 = False
        if not conf.CONFIG_SET('HAVE_KRB5_KT_FREE_ENTRY') and \
           not conf.CONFIG_SET('HAVE_KRB5_FREE_KEYTAB_ENTRY_CONTENTS'):
            Logs.warn("no KT_FREE_FUNCTION detected")
            use_ads_krb5 = False
        if not conf.CONFIG_SET('HAVE_KRB5_C_VERIFY_CHECKSUM'):
            Logs.warn("krb5_c_verify_checksum_compare not found in -lkrb5")
            use_ads_krb5 = False

        # We don't actually use
        # gsskrb5_extract_authz_data_from_sec_context, but it is a
        # clue that this Heimdal, which does the PAC processing we
        # need on the standard gss_inquire_sec_context_by_oid
        if not conf.CONFIG_SET('HAVE_GSS_GET_NAME_ATTRIBUTE') and \
            not (conf.CONFIG_SET('HAVE_GSSKRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT') and \
                     conf.CONFIG_SET('HAVE_GSS_INQUIRE_SEC_CONTEXT_BY_OID')):
            Logs.warn("need either gss_get_name_attribute or gsskrb5_extract_authz_data_from_sec_context and gss_inquire_sec_context_by_oid in -lgssapi for PAC support")
            use_ads_krb5 = False

        if not conf.CONFIG_SET('HAVE_GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT'):
            Logs.warn("need gss_krb5_export_lucid_sec_context for SPNEGO and gss_wrap support")
            use_ads_krb5 = False

        if use_ads_krb5:
            conf.DEFINE('HAVE_KRB5', '1')
            conf.env['HAVE_KRB5'] = '1'
        else:
            conf.undefine('HAVE_KRB5_H')
            conf.undefine('HAVE_GSSAPI_H')
            conf.undefine('HAVE_GSSAPI_GSSAPI_GENERIC_H')
            conf.undefine('HAVE_GSSAPI_GSSAPI_H')
            use_ads = False

        if not conf.CONFIG_SET('HAVE_LDAP'):
            use_ads = False
            use_ads_ldap = False

    if use_ads:
        conf.DEFINE('WITH_ADS', '1')
        conf.env['HAVE_ADS'] = '1'
        Logs.info("Building with Active Directory support.")
    elif Options.options.with_ads == False:
        Logs.info("Building without Active Directory support (--without-ads).")
    else:
        if not use_ads_krb5:
            Logs.warn("Active Directory support not available: krb5 libs don't have all required features")
        if not use_ads_ldap:
            Logs.warn("Active Directory support not available: LDAP support is not available.")
        if Options.options.with_ads:
            conf.fatal("Active Directory support not found. Use --without-ads "
                       "for building without Active Directory support. "
                       "ADS support improves communication with "
                       "Active Directory domain controllers.")
        else:
            # this is the auto-mode case
            Logs.warn("Building without Active Directory support.")


    if Options.options.with_utmp:
        conf.env.with_utmp = True
        if not conf.CHECK_HEADERS('utmp.h'): conf.env.with_utmp = False
        conf.CHECK_FUNCS('pututline pututxline updwtmp updwtmpx getutmpx getutxent')
        conf.CHECK_STRUCTURE_MEMBER('struct utmp', 'ut_name', headers='utmp.h',
                                    define='HAVE_UT_UT_NAME')
        conf.CHECK_STRUCTURE_MEMBER('struct utmp', 'ut_user', headers='utmp.h',
                                    define='HAVE_UT_UT_USER')
        conf.CHECK_STRUCTURE_MEMBER('struct utmp', 'ut_id', headers='utmp.h',
                                    define='HAVE_UT_UT_ID')
        conf.CHECK_STRUCTURE_MEMBER('struct utmp', 'ut_host', headers='utmp.h',
                                    define='HAVE_UT_UT_HOST')
        conf.CHECK_STRUCTURE_MEMBER('struct utmp', 'ut_time', headers='utmp.h',
                                    define='HAVE_UT_UT_TIME')
        conf.CHECK_STRUCTURE_MEMBER('struct utmp', 'ut_tv', headers='utmp.h',
                                    define='HAVE_UT_UT_TV')
        conf.CHECK_STRUCTURE_MEMBER('struct utmp', 'ut_type', headers='utmp.h',
                                    define='HAVE_UT_UT_TYPE')
        conf.CHECK_STRUCTURE_MEMBER('struct utmp', 'ut_pid', headers='utmp.h',
                                    define='HAVE_UT_UT_PID')
        conf.CHECK_STRUCTURE_MEMBER('struct utmp', 'ut_exit.e_exit', headers='utmp.h',
                                    define='HAVE_UT_UT_EXIT')
        conf.CHECK_STRUCTURE_MEMBER('struct utmpx', 'ut_syslen', headers='utmpx.h',
                                    define='HAVE_UX_UT_SYSLEN')
        conf.CHECK_CODE('struct utmp utarg; struct utmp *utreturn; utreturn = pututline(&utarg);',
                        'PUTUTLINE_RETURNS_UTMP', headers='utmp.h',
                        msg="Checking whether pututline returns pointer")
        conf.CHECK_SIZEOF(['((struct utmp *)NULL)->ut_line'], headers='utmp.h',
                          define='SIZEOF_UTMP_UT_LINE', critical=False)
        if not conf.CONFIG_SET('SIZEOF_UTMP_UT_LINE'):
            conf.env.with_utmp = False
        elif int(conf.env.SIZEOF_UTMP_UT_LINE) < 15:
            conf.env.with_utmp = False
        if conf.env.with_utmp:
            conf.DEFINE('WITH_UTMP', 1)
        else:
            Logs.warn("--with-utmp but utmp support not sufficient")

    if Options.options.with_avahi:
        conf.env.with_avahi = True
        if not conf.CHECK_HEADERS('avahi-common/watch.h avahi-client/client.h'): conf.env.with_avahi = False
        if not conf.CHECK_FUNCS_IN('avahi_client_new', 'avahi-client'): conf.env.with_avahi = False
        if not conf.CHECK_FUNCS_IN('avahi_strerror', 'avahi-common'): conf.env.with_avahi = False
        if conf.env.with_avahi:
            conf.DEFINE('WITH_AVAHI_SUPPORT', 1)
    else:
        conf.SET_TARGET_TYPE('avahi-common', 'EMPTY')
        conf.SET_TARGET_TYPE('avahi-client', 'EMPTY')

    if Options.options.with_iconv:
        conf.env.with_iconv = True
        if not conf.CHECK_FUNCS_IN('iconv_open', 'iconv', headers='iconv.h'):
            conf.env.with_iconv = False
        if conf.env.with_iconv:
            conf.DEFINE('HAVE_ICONV', 1)

    if Options.options.with_pam:
        use_pam=True
        conf.CHECK_HEADERS('security/pam_appl.h pam/pam_appl.h')
        if not conf.CONFIG_SET('HAVE_SECURITY_PAM_APPL_H') and not conf.CONFIG_SET('HAVE_PAM_PAM_APPL_H'):
            Logs.warn("--with-pam=yes but pam_appl.h not found")
            use_pam=False
        conf.CHECK_FUNCS_IN('pam_get_data', 'pam')
        conf.CHECK_HEADERS('security/pam_modules.h pam/pam_modules.h')
        if not conf.CONFIG_SET('HAVE_SECURITY_PAM_MODULES_H') and not conf.CONFIG_SET('HAVE_PAM_PAM_MODULES_H'):
            Logs.warn("--with-pam=yes but pam_modules.h not found")
            use_pam=False
        conf.CHECK_HEADERS('security/pam_ext.h security/_pam_macros.h')
        conf.CHECK_HEADERS('pam/pam_ext.h pam/_pam_macros.h')
        conf.CHECK_FUNCS_IN('pam_vsyslog', 'pam')
        conf.CHECK_CODE('''
#if defined(HAVE_SECURITY_PAM_APPL_H)
#include <security/pam_appl.h>
#elif defined(HAVE_PAM_PAM_APPL_H)
#include <pam/pam_appl.h>
#endif
pam_set_item(0, PAM_RHOST, 0);
''',
            'HAVE_PAM_RHOST',
            lib='pam',
            msg="Checking whether PAM_RHOST is available");
        conf.CHECK_CODE('''
#if defined(HAVE_SECURITY_PAM_APPL_H)
#include <security/pam_appl.h>
#elif defined(HAVE_PAM_PAM_APPL_H)
#include <pam/pam_appl.h>
#endif
pam_set_item(0, PAM_TTY, 0);
''',
            'HAVE_PAM_TTY',
            lib='pam',
            msg="Checking whether PAM_TTY is available");
        conf.CHECK_CODE('''
#if (!defined(LINUX))

#define PAM_EXTERN extern
#if defined(HAVE_SECURITY_PAM_APPL_H)
#include <security/pam_appl.h>
#elif defined(HAVE_PAM_PAM_APPL_H)
#include <pam/pam_appl.h>
#endif

#endif

#if defined(HAVE_SECURITY_PAM_MODULES_H)
#include <security/pam_modules.h>
#elif defined(HAVE_PAM_PAM_MODULES_H)
#include <pam/pam_modules.h>
#endif

#if defined(HAVE_SECURITY__PAM_MACROS_H)
#include <security/_pam_macros.h>
#elif defined(HAVE_PAM__PAM_MACROS_H)
#include <pam/_pam_macros.h>
#endif

#ifdef HAVE_SECURITY_PAM_EXT_H
#include <security/pam_ext.h>
#endif

int i; i = PAM_RADIO_TYPE;
''',
            'HAVE_PAM_RADIO_TYPE',
            lib='pam',
            msg="Checking whether PAM_RADIO_TYPE is available");
        if use_pam:
            conf.DEFINE('WITH_PAM', 1)
            conf.DEFINE('WITH_PAM_MODULES', 1)

    if Options.options.with_pam_smbpass:
        conf.env.with_pam_smbpass = True

    seteuid = False

#
# Ensure we select the correct set of system calls on Linux.
#
    if (host_os.rfind('linux') > -1):
        conf.CHECK_CODE('''
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <errno.h>

#ifdef HAVE_SYS_PRIV_H
#include <sys/priv.h>
#endif
#ifdef HAVE_SYS_ID_H
#include <sys/id.h>
#endif

#if defined(HAVE_SYSCALL_H)
#include <syscall.h>
#endif

#if defined(HAVE_SYS_SYSCALL_H)
#include <sys/syscall.h>
#endif

syscall(SYS_setresuid32, -1, -1, -1);
syscall(SYS_setresgid32, -1, -1, -1);
syscall(SYS_setreuid32, -1, -1);
syscall(SYS_setregid32, -1, -1);
syscall(SYS_setuid32, -1);
syscall(SYS_setgid32, -1);
syscall(SYS_setgroups32, 0, NULL);
''',
            'USE_LINUX_32BIT_SYSCALLS',
            msg="Checking whether Linux should use 32-bit credential calls");

        if (conf.CONFIG_SET('USE_LINUX_32BIT_SYSCALLS')):
            seteuid = conf.CHECK_CODE('''
                                #define AUTOCONF_TEST 1
                                #define USE_LINUX_THREAD_CREDENTIALS 1
                                #define USE_LINUX_32BIT_SYSCALLS 1
                                #include "../lib/util/setid.c"
                                #include "./lib/util_sec.c"
                                ''',
                                'USE_LINUX_THREAD_CREDENTIALS',
                                addmain=False,
                                execute=True,
                                msg="Checking whether we can use Linux thread-specific credentials with 32-bit system calls")
        else:
            seteuid = conf.CHECK_CODE('''
                                #define AUTOCONF_TEST 1
                                #define USE_LINUX_THREAD_CREDENTIALS 1
                                #include "../lib/util/setid.c"
                                #include "./lib/util_sec.c"
                                ''',
                                'USE_LINUX_THREAD_CREDENTIALS',
                                addmain=False,
                                execute=True,
                                msg="Checking whether we can use Linux thread-specific credentials")
    if not seteuid:
        seteuid = conf.CHECK_CODE('''
                                #define AUTOCONF_TEST 1
                                #define USE_SETREUID 1
                                #include "../lib/util/setid.c"
                                #include "./lib/util_sec.c"
                                ''',
                                'USE_SETREUID',
                                addmain=False,
                                execute=True,
                                msg="Checking whether setreuid is available")
    if not seteuid:
        seteuid = conf.CHECK_CODE('''
                                #define AUTOCONF_TEST 1
                                #define USE_SETRESUID 1
                                #include "../lib/util/setid.c"
                                #include "./lib/util_sec.c"
                                ''',
                                'USE_SETRESUID',
                                addmain=False,
                                execute=True,
                                msg="Checking whether setresuid is available")
    if not seteuid:
        seteuid = conf.CHECK_CODE('''
                                #define AUTOCONF_TEST 1
                                #define USE_SETEUID 1
                                #include "../lib/util/setid.c"
                                #include "./lib/util_sec.c"
                                ''',
                                'USE_SETEUID',
                                addmain=False,
                                execute=True,
                                msg="Checking whether seteuid is available")
    if not seteuid:
        seteuid = conf.CHECK_CODE('''
                                #define AUTOCONF_TEST 1
                                #define USE_SETUIDX 1
                                #include "../lib/util/setid.c"
                                #include "./lib/util_sec.c"
                                ''',
                                'USE_SETUIDX',
                                addmain=False,
                                execute=True,
                                mandatory=True,
                                msg="Checking whether setuidx is available")
    if Options.options.with_dnsupdate:
        if not conf.CONFIG_SET('HAVE_KRB5'):
            Logs.warn("--with-dnsupdate=yes but gssapi support not sufficient")
        else:
            conf.DEFINE('WITH_DNS_UPDATES', 1)
    conf.CHECK_HEADERS('valgrind.h valgrind/valgrind.h valgrind/memcheck.h')
    if Options.options.developer:
        if conf.CONFIG_SET('HAVE_VALGRIND_H') or conf.CONFIG_SET('HAVE_VALGRIND_VALGRIND_H'):
            conf.DEFINE('VALGRIND', '1')

    if conf.CHECK_CODE('''
#include <bits/sockaddr.h>
#include <linux/netlink.h>
''',
                'HAVE_LINUX_NETLINK_H',
                msg="Checking whether Linux netlink is available"):

        conf.CHECK_CODE('''
#include <bits/sockaddr.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
''',
                'HAVE_LINUX_RTNETLINK_H',
                msg='Checking whether Linux rtnetlink is available')

    conf.CHECK_CODE('''
#include "../tests/fcntl_lock.c"
''',
                'HAVE_FCNTL_LOCK',
                addmain=False,
                execute=True,
                msg='Checking whether fcntl locking is available')

# glibc up to 2.3.6 had dangerously broken posix_fallocate(). DON'T USE IT.
    if not conf.CHECK_CODE('''
#define _XOPEN_SOURCE 600
#include <stdlib.h>
#if defined(__GLIBC__) && ((__GLIBC__ < 2) || (__GLIBC__ == 2 && __GLIBC_MINOR__ < 4))
#error probably broken posix_fallocate
#endif
''',
                           '_HAVE_UNBROKEN_POSIX_FALLOCATE',
                           msg='Checking for broken posix_fallocate'):
        conf.DEFINE('HAVE_BROKEN_POSIX_FALLOCATE', '1')


    conf.CHECK_STRUCTURE_MEMBER('struct stat', 'st_mtim.tv_nsec',
                                define='HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC') # Linux, Solaris
    conf.CHECK_STRUCTURE_MEMBER('struct stat', 'st_mtimensec',
                                define='HAVE_STRUCT_STAT_ST_MTIMENSEC') # BSD, if defined _POSIX_SOURCE
    conf.CHECK_STRUCTURE_MEMBER('struct stat', 'st_mtimespec.tv_nsec',
                                define='HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC') # BSD, if not defined _POSIX_SOURCE
    conf.CHECK_STRUCTURE_MEMBER('struct stat', 'st_mtime_n',
                                define='HAVE_STRUCT_STAT_ST_MTIME_N') # AIX
    conf.CHECK_STRUCTURE_MEMBER('struct stat', 'st_umtime',
                                define='HAVE_STRUCT_STAT_ST_UMTIME') # Tru64
    if conf.CONFIG_SET('HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC') or \
       conf.CONFIG_SET('HAVE_STRUCT_STAT_ST_MTIMENSEC') or \
       conf.CONFIG_SET('HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC') or \
       conf.CONFIG_SET('HAVE_STRUCT_STAT_ST_MTIME_N') or \
       conf.CONFIG_SET('HAVE_STRUCT_STAT_ST_UMTIME'):
        conf.DEFINE('HAVE_STAT_HIRES_TIMESTAMPS', '1')

    # recent FreeBSD, NetBSD have creation timestamps called birthtime:
    conf.CHECK_STRUCTURE_MEMBER('struct stat', 'st_birthtime',
                                define='HAVE_STRUCT_STAT_ST_BIRTHTIME')
    conf.CHECK_STRUCTURE_MEMBER('struct stat', 'st_birthtimespec.tv_nsec',
                                define='HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC')
    conf.CHECK_STRUCTURE_MEMBER('struct stat', 'st_birthtimensec',
                                define='HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC')

    conf.CHECK_CODE('''
ssize_t err = posix_fadvise(0,0,0x80000,POSIX_FADV_WILLNEED);
''',
                'HAVE_POSIX_FADVISE',
                msg='Checking whether posix_fadvise is available',
                headers='unistd.h fcntl.h')

    for v in ['_SC_NGROUPS_MAX', '_SC_NPROC_ONLN', '_SC_NPROCESSORS_ONLN', '_SC_PAGESIZE' ]:
        conf.CHECK_CODE('''
                        #include <unistd.h>
                        return sysconf(%s) == -1 ? 1 : 0;
                        ''' % v,
                        'SYSCONF%s' % v,
                        msg='Checking whether sysconf(%s) is available' % v)

    conf.CHECK_CODE('''
#include <sys/syscall.h>
#include <unistd.h>
syscall(SYS_initgroups, 16, NULL, NULL, 0);
                    ''',
                    'HAVE_DARWIN_INITGROUPS',
                    msg='Checking whether to use the Darwin-specific initgroups system call')

    conf.CHECK_CODE('''struct utimbuf tbuf;  tbuf.actime = 0; tbuf.modtime = 1; exit(utime("foo.c",&tbuf));''',
                    'HAVE_UTIMBUF',
                    headers='sys/types.h utime.h',
                    msg='Checking whether struct utimbuf is available')

    if conf.CHECK_CODE('''struct sigevent s;''',
                    'HAVE_STRUCT_SIGEVENT',
                    headers='sys/types.h stdlib.h stddef.h signal.h',
                    msg='Checking whether we have the struct sigevent'):
        conf.CHECK_STRUCTURE_MEMBER('struct sigevent', 'sigev_value.sival_ptr',
                                    define='HAVE_STRUCT_SIGEVENT_SIGEV_VALUE_SIVAL_PTR',
                                    headers='signal.h');
        conf.CHECK_STRUCTURE_MEMBER('struct sigevent', 'sigev_value.sigval_ptr',
                                    define='HAVE_STRUCT_SIGEVENT_SIGEV_VALUE_SIGVAL_PTR',
                                    headers='signal.h');

    if os.path.exists('/proc/sys/kernel/core_pattern'):
        conf.DEFINE('HAVE_SYS_KERNEL_PROC_CORE_PATTERN', '1')

    if conf.CHECK_CODE('''
#include <time.h>
main() {
        struct tm *tm;
        if (sizeof(time_t) == 8) {
                time_t max_time = 0x7fffffffffffffffll;
                tm = gmtime(&max_time);
                /* This should fail with 32-bit tm_year. */
                if (tm == NULL) {
                        /* Max time_t that works with 32-bit int tm_year in struct tm. */
                        max_time = 67768036191676799ll;
                        tm = gmtime(&max_time);
                        if (tm) {
                                exit(0);
                        }
                }
        }
        exit(1);
}''',
        '__TIME_T_MAX',
        addmain=False,
        execute=True,
        msg="Checking for the maximum value of the 'time_t' type"):
            conf.DEFINE('TIME_T_MAX', '67768036191676799ll')

    conf.CHECK_CODE('''
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <sys/types.h>
main() { dev_t dev = makedev(1,2); return 0; }
''',
        'HAVE_MAKEDEV',
        addmain=False,
        msg='Checking whether the macro for makedev is available')

    conf.CHECK_CODE('''
#include <stdio.h>
#include <limits.h>
#include <signal.h>

void exit_on_core(int ignored) {
        exit(1);
}

main() {
        char *newpath;
        signal(SIGSEGV, exit_on_core);
        newpath = realpath("/tmp", NULL);
        exit((newpath != NULL) ? 0 : 1);
}
''',
        'REALPATH_TAKES_NULL',
        addmain=False,
        execute=True,
        msg='Checking whether the realpath function allows a NULL argument')

    conf.CHECK_CODE('''#include "../tests/ftruncate.c"''',
                    'HAVE_FTRUNCATE_EXTEND',
                    msg='Checking for ftruncate extend',
                    addmain=False,
                    execute=True)

    if Options.options.with_sendfile_support:
        if (host_os.rfind('linux') > -1) or (host_os.rfind('gnu') > -1) or (host_os.rfind('k*bsd*-gnu') > -1) or (host_os.rfind('kopensolaris*-gnu') > -1):
            conf.CHECK_CODE('''
                            int tofd, fromfd;
                            off_t offset;
                            size_t total;
                            ssize_t nwritten = sendfile(tofd, fromfd, &offset, total);
                            ''',
                            '_HAVE_SENDFILE',
                            headers='sys/sendfile.h',
                            msg='Checking for linux sendfile support')

            if conf.CONFIG_SET('_HAVE_SENDFILE'):
                conf.DEFINE('HAVE_SENDFILE', '1')
                conf.DEFINE('LINUX_SENDFILE_API', '1')
                conf.DEFINE('WITH_SENDFILE', '1')
        elif (host_os.rfind('freebsd') > -1) or (host_os.rfind('dragonfly') > -1):
            conf.CHECK_CODE('''
                            #include <sys/types.h>
                            #include <unistd.h>
                            #include <sys/socket.h>
                            #include <sys/uio.h>
                            int fromfd, tofd, ret, total=0;
                            off_t offset, nwritten;
                            struct sf_hdtr hdr;
                            struct iovec hdtrl;
                            hdr.headers = &hdtrl;
                            hdr.hdr_cnt = 1;
                            hdr.trailers = NULL;
                            hdr.trl_cnt = 0;
                            hdtrl.iov_base = NULL;
                            hdtrl.iov_len = 0;
                            ret = sendfile(fromfd, tofd, offset, total, &hdr, &nwritten, 0)
                            ''',
                            '_HAVE_SENDFILE',
                            msg='Checking for freebsd sendfile support')
            if conf.CONFIG_SET('_HAVE_SENDFILE'):
                conf.DEFINE('HAVE_SENDFILE', '1')
                conf.DEFINE('FREEBSD_SENDFILE_API', '1')
                conf.DEFINE('WITH_SENDFILE', '1')
        elif (host_os.rfind('darwin') > -1):
            conf.CHECK_CODE('''
                            #include <sys/types.h>
                            #include <sys/socket.h>
                            #include <sys/uio.h>
                            int fromfd, tofd, ret;
                            off_t offset, nwritten;
                            struct sf_hdtr hdr;
                            struct iovec hdtrl;
                            hdr.headers = &hdtrl;
                            hdr.hdr_cnt = 1;
                            hdr.trailers = (void *)0;
                            hdr.trl_cnt = 0;
                            hdtrl.iov_base = (void *)0;
                            hdtrl.iov_len = 0;
			    ret = sendfile(fromfd, tofd, offset, &nwritten, &hdr, 0);
                            ''',
                            '_HAVE_SENDFILE',
                            msg='Checking for darwin sendfile support')
            if conf.CONFIG_SET('_HAVE_SENDFILE'):
                conf.DEFINE('HAVE_SENDFILE', '1')
                conf.DEFINE('DARWIN_SENDFILE_API', '1')
                conf.DEFINE('WITH_SENDFILE', '1')
        elif (host_os.rfind('hpux') > -1) or (host_os.rfind('osf') > -1):
            conf.CHECK_CODE('''
                            #include <sys/socket.h>
                            #include <sys/uio.h>
                            int fromfd, tofd;
                            size_t total=0;
                            struct iovec hdtrl[2];
                            ssize_t nwritten;
                            off_t offset;
                            hdtrl[0].iov_base = 0;
                            hdtrl[0].iov_len = 0;
                            nwritten = sendfile(tofd, fromfd, offset, total, &hdtrl[0], 0);
                            ''',
                            '_HAVE_SENDFILE',
                            msg='Checking for osf/hpux sendfile support')
            if conf.CONFIG_SET('_HAVE_SENDFILE'):
                conf.DEFINE('HAVE_SENDFILE', '1')
                conf.DEFINE('HPUX_SENDFILE_API', '1')
                conf.DEFINE('WITH_SENDFILE', '1')
        elif (host_os.rfind('solaris') > -1):
            conf.CHECK_FUNCS_IN('sendfile', 'sendfilev')
            conf.CHECK_CODE('''
                            #include <sys/sendfile.h>,
                            int sfvcnt;
                            size_t xferred;
                            struct sendfilevec vec[2];
                            ssize_t nwritten;
                            int tofd;
                            sfvcnt = 2;
                            vec[0].sfv_fd = SFV_FD_SELF;
                            vec[0].sfv_flag = 0;
                            vec[0].sfv_off = 0;
                            vec[0].sfv_len = 0;
                            vec[1].sfv_fd = 0;
                            vec[1].sfv_flag = 0;
                            vec[1].sfv_off = 0;
                            vec[1].sfv_len = 0;
                            nwritten = sendfilev(tofd, vec, sfvcnt, &xferred);
                            ''',
                            '_HAVE_SENDFILEV',
                            msg='Checking for solaris sendfilev support')
            if conf.CONFIG_SET('_HAVE_SENDFILEV'):
                conf.DEFINE('HAVE_SENDFILEV', '1')
                conf.DEFINE('SOLARIS_SENDFILE_API', '1')
                conf.DEFINE('WITH_SENDFILE', '1')
        elif (host_os.rfind('aix') > -1):
            conf.CHECK_CODE('''
                            #include <sys/socket.h>
                            int fromfd, tofd;
                            size_t total=0;
                            struct sf_parms hdtrl;
                            ssize_t nwritten;
                            hdtrl.header_data = 0;
                            hdtrl.header_length = 0;
                            hdtrl.file_descriptor = fromfd;
                            hdtrl.file_offset = 0;
                            hdtrl.file_bytes = 0;
                            hdtrl.trailer_data = 0;
                            hdtrl.trailer_length = 0;
                            nwritten = send_file(&tofd, &hdtrl, 0);
                            ''',
                            '_HAVE_SENDFILE',
                            msg='Checking for AIX send_file support')
            if conf.CONFIG_SET('_HAVE_SENDFILE'):
                conf.DEFINE('HAVE_SENDFILE', '1')
                conf.DEFINE('AIX_SENDFILE_API', '1')
                conf.DEFINE('WITH_SENDFILE', '1')

    # Check for getcwd allowing a NULL arg.
    conf.CHECK_CODE('''
#include <unistd.h>
main() {
        char *s = getcwd(NULL,0);
        exit(s != NULL ?  0 : 1);
}''', 'GETCWD_TAKES_NULL', addmain=False, execute=True,
        msg="getcwd takes a NULL argument")


    # UnixWare 7.x has its getspnam in -lgen
    conf.CHECK_FUNCS_IN('getspnam', 'gen')
    conf.CHECK_FUNCS_IN('getspnam', 'security')
    conf.CHECK_FUNCS_IN('getspnam', 'sec')

    if Options.options.with_quotas:
        # For quotas on Veritas VxFS filesystems
        conf.CHECK_HEADERS('sys/fs/vx_quota.h')
        # For sys/quota.h and linux/quota.h
        conf.CHECK_HEADERS('sys/quota.h')
        # For quotas on BSD systems
        conf.CHECK_HEADERS('ufs/ufs/quota.h')
        # For quotas on Linux XFS filesystems
        if conf.CHECK_HEADERS('xfs/xqm.h'):
            conf.DEFINE('HAVE_XFS_QUOTAS', '1')
        else:
            # For Irix XFS
            conf.CHECK_CODE('''
                #include "confdefs.h"
                #ifdef HAVE_SYS_TYPES_H
                #include <sys/types.h>
                #endif
                #ifdef HAVE_ASM_TYPES_H
                #include <asm/types.h>
                #endif
                #include <sys/quota.h>
                int i = Q_XGETQUOTA;''',
                define='HAVE_XFS_QUOTAS',
                msg='for XFS QUOTA in <sys/quota.h>',
                execute=False,
                local_include=False)
        
        # For IRIX like dqb_isoftlimit instead of dqb_fsoftlimit in struc dqblk
        conf.CHECK_STRUCTURE_MEMBER('struct dqblk', 'dqb_fsoftlimit', define='HAVE_DQB_FSOFTLIMIT',
                                headers='sys/quota.h')
        #darwin style quota bytecount
        conf.CHECK_STRUCTURE_MEMBER('struct dqblk', 'dqb_curbytes', define='HAVE_STRUCT_DQBLK_DQB_CURBYTES',
                                headers='sys/quota.h')
        if conf.CHECK_HEADERS('rpcsvc/rquota.h'):
            conf.DEFINE('HAVE_NFS_QUOTAS', '1')
            conf.CHECK_STRUCTURE_MEMBER('struct getquota_rslt', 'getquota_rslt_u',
                                        define='HAVE_GETQUOTA_RSLT_GETQUOTA_RSLT_U',
                                        headers='rpcsvc/rquota.h')

        if (host_os.rfind('linux') > -1):
            conf.DEFINE('HAVE_QUOTACTL_LINUX', '1')
        elif not conf.CONFIG_SET("HAVE_XFS_QUOTAS"):
            if not conf.CHECK_CODE('''
                #define HAVE_QUOTACTL_4A 1
                #define AUTOCONF_TEST 1
                #include "../tests/sysquotas.c"
                ''',
                                   cflags=conf.env['WERROR_CFLAGS'],
                                   define='HAVE_QUOTACTL_4A',
                                   msg='for QUOTACTL_4A: long quotactl(int cmd, char *special, qid_t id, caddr_t addr)',
                                   execute=True,
                                   addmain=False):

                conf.CHECK_CODE('''
                #define HAVE_QUOTACTL_4B 1
                #define AUTOCONF_TEST 1
                #include "../tests/sysquotas.c"
                ''',
                                cflags=conf.env['WERROR_CFLAGS'],
                                define='HAVE_QUOTACTL_4B',
                                msg='for QUOTACTL_4B:  int quotactl(const char *path, int cmd, int id, char *addr)',
                                execute=True,
                                addmain=False)

        conf.CHECK_CODE('''
                     clnt_create("", RQUOTAPROG, RQUOTAVERS, "udp");
''', 
                        headers="rpc/rpc.h rpc/types.h rpcsvc/rquota.h rpc/nettype.h rpc/xdr.h", 
                        define='HAVE_NFS_QUOTAS',
                        msg='for NFS QUOTAS',
                        execute=True,
                        local_include=False)

        if conf.CONFIG_SET('HAVE_QUOTACTL_LINUX') or \
           conf.CONFIG_SET('HAVE_QUOTACTL_4A') or \
           conf.CONFIG_SET('HAVE_QUOTACTL_4B') or \
           conf.CONFIG_SET('HAVE_XFS_QUOTAS'):
            conf.DEFINE('HAVE_SYS_QUOTAS', '1')
            conf.DEFINE('WITH_QUOTAS', '1')

    #
    # cluster support (CTDB)
    #
    if not Options.options.with_cluster_support:
        Logs.info("building without cluster support (--without-cluster-support)")
        conf.env.with_ctdb = False
    else:
        Logs.info("building with cluster support")
        conf.env['CTDB_CFLAGS'] = '-DCLUSTER_SUPPORT=1'
        conf.env['CTDB_INCLUDE'] = conf.srcdir + '/ctdb/include'
        conf.env.with_ctdb = True

    conf.CHECK_CODE('__attribute__((destructor)) static void cleanup(void) { }',
                    'HAVE_FUNCTION_ATTRIBUTE_DESTRUCTOR',
                    addmain=False,
                    link=False,
                    msg='Checking whether we can compile with __attribute__((destructor))')

    conf.CHECK_CODE('void seekdir(DIR *d, long loc) { return; }',
                    'SEEKDIR_RETURNS_VOID',
                    headers='sys/types.h dirent.h',
                    msg='Checking whether seekdir returns void')

    if Options.options.with_profiling_data:
        conf.DEFINE('WITH_PROFILE', 1);

    if Options.options.with_pthreadpool:
        if conf.CONFIG_SET('HAVE_PTHREAD'):
            conf.DEFINE('WITH_PTHREADPOOL', '1')
        else:
            Logs.warn("pthreadpool support cannot be enabled when pthread support was not found")
            conf.undefine('WITH_PTHREADPOOL')

    if conf.CHECK_HEADERS('gpfs_gpl.h'):
        conf.DEFINE('HAVE_GPFS', '1')

    if (conf.CHECK_HEADERS('linux/ioctl.h sys/ioctl.h linux/fs.h') and
	conf.CHECK_DECLS('FS_IOC_GETFLAGS FS_COMPR_FL', headers='linux/fs.h')):
	    conf.DEFINE('HAVE_LINUX_IOCTL', '1')

    conf.env['CCFLAGS_CEPHFS'] = "-D_FILE_OFFSET_BITS=64"
    if Options.options.libcephfs_dir:
        conf.env['CPPPATH_CEPHFS'] = Options.options.libcephfs_dir + '/include'
        conf.env['LIBPATH_CEPHFS'] = Options.options.libcephfs_dir + '/lib'

    if conf.CHECK_HEADERS('cephfs/libcephfs.h', False, False, 'cephfs') and conf.CHECK_LIB('cephfs'):
        conf.DEFINE('HAVE_CEPH', '1')

    if Options.options.with_glusterfs:
        conf.check_cfg(package='glusterfs-api', args='"glusterfs-api >= 4" --cflags --libs',
                       msg='Checking for glusterfs-api >= 4', uselib_store="GFAPI")
        conf.CHECK_HEADERS('api/glfs.h', lib='gfapi')
        conf.CHECK_LIB('gfapi', shlib=True)

        if conf.CONFIG_SET('HAVE_API_GLFS_H'):
            conf.DEFINE('HAVE_GLUSTERFS', '1')
        else:
            conf.SET_TARGET_TYPE('gfapi', 'EMPTY')
            conf.undefine('HAVE_GLUSTERFS')
    else:
        conf.SET_TARGET_TYPE('gfapi', 'EMPTY')
        conf.undefine('HAVE_GLUSTERFS')

    if Options.options.enable_vxfs:
	conf.DEFINE('HAVE_VXFS', '1')

    if conf.check_cfg(package='dbus-1', args='--cflags --libs',
                      msg='Checking for dbus', uselib_store="DBUS-1"):
        if (conf.CHECK_HEADERS('dbus/dbus.h', lib='dbus-1')
                                      and conf.CHECK_LIB('dbus-1', shlib=True)):
            conf.DEFINE('HAVE_DBUS', '1')

    conf.env.build_regedit = False
    if not Options.options.with_regedit == False:
        conf.PROCESS_SEPARATE_RULE('system_ncurses')
        if conf.CONFIG_SET('HAVE_NCURSES'):
            conf.env.build_regedit = True

    if conf.env.build_regedit:
        Logs.info("building regedit")
    else:
        if Options.options.with_regedit == False:
            Logs.info("not building regedit (--without-regedit)")
        elif Options.options.with_regedit == True:
            Logs.error("ncurses not available, cannot build regedit")
            conf.fatal("ncurses not available, but --with-regedit was specified")
        else:
            Logs.info("ncurses not available, not building regedit")

    conf.CHECK_FUNCS_IN('DES_pcbc_encrypt', 'crypto')
    if Options.options.with_fake_kaserver == True:
        conf.CHECK_HEADERS('afs/param.h afs/stds.h', together=True)
        conf.CHECK_HEADERS('afs/param.h afs/stds.h', together=True)
        if (conf.CONFIG_SET('HAVE_AFS_PARAM_H') and conf.CONFIG_SET('HAVE_AFS_STDS_H') and conf.CONFIG_SET('HAVE_DES_PCBC_ENCRYPT')):
            conf.DEFINE('WITH_FAKE_KASERVER', '1')
        else:
            conf.fatal('AFS headers not available, but --with-fake-kaserver was specified')



    default_static_modules.extend(TO_LIST('''pdb_smbpasswd pdb_tdbsam pdb_wbc_sam
                                      auth_sam auth_unix auth_winbind auth_wbc
                                      auth_domain auth_builtin vfs_default
                                      nss_info_template idmap_tdb idmap_passdb
                                      idmap_nss'''))

    default_shared_modules.extend(TO_LIST('''vfs_recycle vfs_audit vfs_extd_audit vfs_full_audit vfs_netatalk
                                      vfs_fake_perms vfs_default_quota vfs_readonly vfs_cap
                                      vfs_expand_msdfs vfs_shadow_copy vfs_shadow_copy2 
                                      auth_script vfs_readahead vfs_xattr_tdb vfs_posix_eadb
                                      vfs_streams_xattr vfs_streams_depot vfs_acl_xattr vfs_acl_tdb
                                      vfs_smb_traffic_analyzer vfs_preopen vfs_catia vfs_scannedonly
				      vfs_media_harmony vfs_fruit
				      vfs_commit
				      vfs_worm
                                      vfs_crossrename vfs_linux_xfs_sgid
                                      vfs_time_audit idmap_autorid idmap_tdb2
                                      idmap_ad
                                      idmap_rid idmap_hash idmap_rfc2307'''))

    if Options.options.developer:
        default_static_modules.extend(TO_LIST('charset_weird'))
        default_shared_modules.extend(TO_LIST('perfcount_test'))
        default_shared_modules.extend(TO_LIST('vfs_skel_opaque vfs_skel_transparent vfs_shadow_copy_test'))
        default_shared_modules.extend(TO_LIST('auth_skel pdb_test'))

    if Options.options.enable_selftest or Options.options.developer:
	default_shared_modules.extend(TO_LIST('vfs_fake_acls vfs_nfs4acl_xattr'))
        

    if conf.CONFIG_SET('AD_DC_BUILD_IS_ENABLED'):
        default_static_modules.extend(TO_LIST('pdb_samba_dsdb auth_samba4 vfs_dfs_samba4'))

    if conf.CONFIG_SET('HAVE_FREEBSD_SUNACL_H'):
        default_shared_modules.extend(TO_LIST('vfs_zfsacl'))

    if conf.CONFIG_SET('HAVE_DIRFD_DECL'):
        default_shared_modules.extend(TO_LIST('vfs_syncops vfs_dirsort'))

    if conf.CONFIG_SET('HAVE_STATFS_F_FSID'):
        default_shared_modules.extend(TO_LIST('vfs_fileid'))

    if (conf.CONFIG_SET('HAVE_STRUCT_MSGHDR_MSG_CONTROL') or conf.CONFIG_SET('HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS')):
        default_shared_modules.extend(TO_LIST('vfs_aio_fork'))

    if Options.options.with_pthreadpool:
        default_shared_modules.extend(TO_LIST('vfs_aio_pthread'))

    if conf.CONFIG_SET('HAVE_AIO'):
        default_shared_modules.extend(TO_LIST('vfs_aio_posix'))

    if conf.CONFIG_SET('HAVE_LINUX_KERNEL_AIO'):
        default_shared_modules.extend(TO_LIST('vfs_aio_linux'))

    if conf.CONFIG_SET('HAVE_LDAP'):
        default_static_modules.extend(TO_LIST('pdb_ldapsam idmap_ldap'))

    if conf.CONFIG_SET('DARWINOS'):
        default_static_modules.extend(TO_LIST('charset_macosxfs'))

    if conf.CONFIG_SET('HAVE_GPFS'):
	default_shared_modules.extend(TO_LIST('vfs_gpfs'))

    if conf.CONFIG_SET('HAVE_LINUX_IOCTL'):
	default_shared_modules.extend(TO_LIST('vfs_btrfs'))

    if conf.CONFIG_SET('SAMBA_FAM_LIBS'):
        default_shared_modules.extend(TO_LIST('vfs_notify_fam'))

    if conf.CONFIG_SET("HAVE_CEPH"):
        default_shared_modules.extend(TO_LIST('vfs_ceph'))

    if conf.CONFIG_SET('HAVE_GLUSTERFS'):
        default_shared_modules.extend(TO_LIST('vfs_glusterfs'))

    if conf.CONFIG_SET('HAVE_VXFS'):
        default_shared_modules.extend(TO_LIST('vfs_vxfs'))

    if conf.CONFIG_SET('HAVE_DBUS'):
	default_shared_modules.extend(TO_LIST('vfs_snapper'))

    explicit_shared_modules = TO_LIST(Options.options.shared_modules, delimiter=',')
    explicit_static_modules = TO_LIST(Options.options.static_modules, delimiter=',')

    def replace_list_item(lst, item, value):
        try:
            idx = lst.index(item)
            lst[idx] = value
        except:
            pass
    # PDB module file name should have the same name as module registers itself
    # In Autoconf build we export LDAP passdb module as ldapsam but WAF build
    # was always exporting pdb_ldap. In order to support existing packages
    # allow referring to pdb_ldapsam as pdb_ldap but use proper name internally.
    replace_list_item(explicit_shared_modules, 'pdb_ldap', 'pdb_ldapsam')
    replace_list_item(explicit_static_modules, 'pdb_ldap', 'pdb_ldapsam')

    final_static_modules = default_static_modules
    final_shared_modules = default_shared_modules

    for m in explicit_static_modules:
        if m in final_shared_modules:
            final_shared_modules.remove(m)
        final_static_modules.append(m)
    for m in explicit_shared_modules:
        if m in final_static_modules:
            final_static_modules.remove(m)
        final_shared_modules.append(m)

    if ("auth_domain" not in final_static_modules) or \
            ("auth_builtin" not in final_static_modules) or \
            ("auth_sam" not in final_static_modules) or \
            ("auth_winbind" not in final_static_modules):
        raise Utils.WafError('These auth modules MUST be configured as static modules: auth_domain, auth_builtin, auth_sam, auth_winbind')

    conf.env['static_modules'] = final_static_modules
    conf.env['shared_modules'] = final_shared_modules

    conf.DEFINE('STRING_STATIC_MODULES', ' '.join(final_static_modules), quote=True)

    static_list = {}
    shared_list = {}

    prefixes = ['vfs', 'pdb', 'auth', 'nss_info', 'charset', 'idmap', 'gpext', 'perfcount']
    conf.env['MODULE_PREFIXES'] = prefixes
    for p in prefixes:
        for m in final_static_modules:
            if m.find(p) == 0:
                if not p in static_list:
                    static_list[p] = []
                static_list[p].append(m)
        for m in final_shared_modules:
            if m.find(p) == 0:
                if not p in shared_list:
                    shared_list[p] = []
                shared_list[p].append(m)

    for p in prefixes:
        static_env = "%s_STATIC" % p.upper()
        shared_env = "%s_SHARED" % p.upper()
        conf.env[static_env] = []
        conf.env[shared_env] = []
        if p in static_list:
            decl_list=""
            for entry in static_list[p]:
                decl_list += "extern NTSTATUS %s_init(void); " % entry
                conf.env[static_env].append('%s' % entry)
            decl_list = decl_list.rstrip()
            conf.DEFINE('static_decl_%s' % p, decl_list)
            conf.DEFINE('static_init_%s' % p, '{ %s_init(); }' % '_init();  '.join(static_list[p]))
        else:
            conf.DEFINE('static_decl_%s' % p, '')
            conf.DEFINE('static_init_%s' % p, '{}')
        if p in shared_list:
            for entry in shared_list[p]:
                conf.DEFINE('%s_init' % entry, 'samba_init_module')
                conf.env[shared_env].append('%s' % entry)

    conf.SAMBA_CONFIG_H('include/config.h')

def ctags(ctx):
    "build 'tags' file using ctags"
    import Utils
    source_root = os.path.dirname(Utils.g_module.root_path)
    cmd = 'ctags $(find %s/.. -name "*.[ch]" | grep -v "*_proto\.h")' % source_root
    print("Running: %s" % cmd)
    os.system(cmd)

